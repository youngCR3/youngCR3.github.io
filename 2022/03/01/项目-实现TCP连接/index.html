<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="CS-144项目要点总结">
<meta property="og:type" content="article">
<meta property="og:title" content="项目-实现TCP连接">
<meta property="og:url" content="http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/index.html">
<meta property="og:site_name" content="元朗食品">
<meta property="og:description" content="CS-144项目要点总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/1.png">
<meta property="og:image" content="http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/2.png">
<meta property="article:published_time" content="2022-03-01T06:03:58.000Z">
<meta property="article:modified_time" content="2022-04-08T12:08:32.869Z">
<meta property="article:author" content="Young">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="项目">
<meta property="article:tag" content="Computer Network">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/1.png">


<link rel="canonical" href="http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/","path":"2022/03/01/项目-实现TCP连接/","title":"项目-实现TCP连接"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>项目-实现TCP连接 | 元朗食品</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">元朗食品</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#tcp%E8%BF%9E%E6%8E%A5"><span class="nav-text">TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#bytestream%E7%B1%BB"><span class="nav-text">ByteStream类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1"><span class="nav-text">功能设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1"><span class="nav-text">成员设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="nav-text">关键问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="nav-text">数据结构与算法设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0"><span class="nav-text">成员实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#streamreassembler%E7%B1%BB"><span class="nav-text">StreamReassembler类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-1"><span class="nav-text">功能设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1-1"><span class="nav-text">成员设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-1"><span class="nav-text">关键问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-1"><span class="nav-text">数据结构与算法设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89-1"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0-1"><span class="nav-text">成员实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-receiver%E7%B1%BB"><span class="nav-text">TCP Receiver类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E5%AD%97%E8%8A%82%E7%BC%96%E5%8F%B7%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">工具函数：字节编号之间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-2"><span class="nav-text">功能设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1-2"><span class="nav-text">成员设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-2"><span class="nav-text">关键问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-2"><span class="nav-text">数据结构与算法设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89-2"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0-2"><span class="nav-text">成员实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-sender%E7%B1%BB"><span class="nav-text">TCP Sender类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1-3"><span class="nav-text">成员设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-3"><span class="nav-text">关键问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1-3"><span class="nav-text">数据结构与算法设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89-3"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0-3"><span class="nav-text">成员实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp-connection%E7%B1%BB"><span class="nav-text">TCP Connection类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-3"><span class="nav-text">功能设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1-4"><span class="nav-text">成员设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-4"><span class="nav-text">关键问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="nav-text">数据结构与算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89-4"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0-4"><span class="nav-text">成员实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-4"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-text">测试结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%87%E5%88%B0%E7%9A%84bug%E6%80%BB%E7%BB%93%E9%81%87%E5%88%B0%E7%9A%84bug%E5%92%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87"><span class="nav-text">遇到的bug（总结遇到的bug和如何解决，面试准备）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="nav-text">网络层、链路层</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-text">路由器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-4"><span class="nav-text">功能设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1-5"><span class="nav-text">成员设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-5"><span class="nav-text">关键问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-1"><span class="nav-text">数据结构与算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89-5"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0-5"><span class="nav-text">成员实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-5"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="nav-text">网络层-控制平面</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="nav-text">路由器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%9F%E8%83%BD%E8%AE%BE%E8%AE%A1-5"><span class="nav-text">功能设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E8%AE%BE%E8%AE%A1-6"><span class="nav-text">成员设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90-6"><span class="nav-text">关键问题分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-2"><span class="nav-text">数据结构与算法分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%AE%9A%E4%B9%89-6"><span class="nav-text">类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9E%E7%8E%B0-6"><span class="nav-text">成员实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-6"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cs-144-lab%E6%9C%80%E7%BB%88%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-text">CS-144 lab最终测试结果</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Young"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Young</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--playlist外链地址-->   
<meting-js
  server="tencent"
  type="playlist" 
  id="8356942170"
  mini="false"
  fixed="false"
  list-folded="true"
  autoplay="false"
  volume="0.4"
  theme="#FADFA3"
  order="list"
  loop="all"
  preload="auto"
  lrc-type="1"
  mutex="true">
</meting-js>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="项目-实现TCP连接 | 元朗食品">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          项目-实现TCP连接
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 14:03:58" itemprop="dateCreated datePublished" datetime="2022-03-01T14:03:58+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E9%A1%B9%E7%9B%AE/" itemprop="url" rel="index"><span itemprop="name">项目</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><strong>CS-144项目要点总结</strong></p>
<span id="more"></span>
<h1 id="tcp连接">TCP连接</h1>
<h2 id="bytestream类"><code>ByteStream</code>类</h2>
<h3 id="功能设计">功能设计</h3>
<ul>
<li><strong>固定大小的缓存区</strong>：本质上是一个具有固定容量的缓存区，读进程可以从中读各个字节，写进程可以往里写入各个字节。当缓存区空时读进程阻塞，缓存区满时写进程阻塞</li>
<li><strong>读者与写者</strong>
<ul>
<li>对<strong>TCP接收方</strong>来说，读进程即上层的应用程序，写进程负责将TCP发送方传来的TCP报文段的有效载荷放入缓存区</li>
<li>对<strong>TCP发送方</strong>来说，写进程即上层的应用程序，读进程即TCP
sender，负责将字节读出放入TCP报文段，并发送出去</li>
</ul></li>
</ul>
<h3 id="成员设计">成员设计</h3>
<ul>
<li><p><code>ByteStream</code>类的数据成员分析</p>
<ul>
<li><code>capacity</code>指示缓存区容量</li>
<li><code>buf</code>存储当前缓存区的字节，可用队列实现</li>
</ul></li>
<li><p><code>ByteStream</code>类的成员函数分析</p>
<ul>
<li><p><code>write(const string&amp;)</code>，将某个字符串的每个字符写入缓存区</p></li>
<li><p><code>read(size_t)</code>，从缓存区读出若干个字节</p></li>
<li><p><code>peek_output(size_t)</code>，返回缓存区最开始的若干个字节</p></li>
<li><p><code>pop_output(size_t)</code>，将缓存区的最开始的若干个字节弹出（应该先调用<code>peek_output</code>读出再调用<code>pop_output</code>弹出）</p></li>
<li><p><code>remaining_capacity()</code>，当前缓存区的剩余容量</p></li>
<li><p><code>buffer_size()</code>，当前缓存区存储的字节数</p></li>
<li><p><code>buffer_empty()</code>，当前缓存区是否为空</p></li>
<li><p><code>input_ended()</code>，读进程调用该方法获取字节流是否已经到达文件结尾</p></li>
<li><p><code>end_input()</code>，写进程调用该方法告知读进程已经没有更多的字节写入</p></li>
<li><p><code>bytes_read()</code>，已经读出的字节数</p></li>
<li><p><code>bytes_write()</code>，已经写入的字节数</p></li>
</ul></li>
</ul>
<h3 id="关键问题分析">关键问题分析</h3>
<ul>
<li><p><strong>读数据</strong>时缓存区为<strong>空</strong>，或<strong>写数据</strong>时缓存区<strong>已满</strong>，应该怎么做？</p>
<ul>
<li>读数据时缓存区为空，则终止此次读操作，只返回已读的字节</li>
<li>写数据时缓存区已满，则终止此次写操作，丢弃剩下的字节，并返回已写入的字节数</li>
</ul></li>
<li><p>如何判定EOF？</p>
<ul>
<li><p>这个EOF可以认为是<strong>为应用层设置的标志</strong>，因此只有当应用层读到所有数据时，才判定为EOF，因此需要<strong>同时考虑读进程和写进程</strong></p></li>
<li><p>当写进程写入最后一个字节时，它会调用<code>end_input()</code>告知已经到达文件结尾</p></li>
<li><p>我们还需考虑读进程，当读进程在写进程到达文件结尾后，它还需要将缓存区的所有字节读出，此时才认为到达了EOF</p></li>
</ul></li>
</ul>
<h3 id="数据结构与算法设计">数据结构与算法设计</h3>
<ul>
<li>考虑按序读写，读进程总是从读出最早写入的字节，写进程总是在已写入的字节后面写入下一个字节，这是一个FIFO的模型，因此可用<strong>队列</strong>实现</li>
<li>特别地，由于接口设计要求<code>peek_output(size_t)</code>要求拷贝缓存区最前面的若干个字节，而<code>std::queue</code>的迭代器不支持算术运算，因此使用<code>std::deque</code>实现，它能够在常数时间内完成<strong>队首、队尾的插入和删除</strong>操作，同时它的<strong>迭代器支持算术运算</strong></li>
</ul>
<h3 id="类定义">类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteStream</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn&#x27;t need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that&#x27;s a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    <span class="keyword">size_t</span> capacity = <span class="number">0</span>;</span><br><span class="line">    deque&lt;<span class="keyword">char</span>&gt; buf;</span><br><span class="line">    <span class="keyword">size_t</span> read_cnt = <span class="number">0</span>, write_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> end = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// omitted</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员实现">成员实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;byte_stream.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a flow-controlled in-memory byte stream.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 0, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab0`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You will need to add private members to the class declaration in `byte_stream.hh`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">ByteStream::<span class="built_in">ByteStream</span>(<span class="keyword">const</span> <span class="keyword">size_t</span> c) &#123;</span><br><span class="line">    capacity = c;</span><br><span class="line">    write_ptr = <span class="number">0</span>;</span><br><span class="line">    read_ptr = <span class="number">0</span>;</span><br><span class="line">    end = <span class="literal">false</span>;</span><br><span class="line">    _buf = deque&lt;<span class="keyword">char</span>&gt;&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="keyword">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">remaining_capacity</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            _buf.<span class="built_in">push_back</span>(ch);</span><br><span class="line">            ++write_ptr;</span><br><span class="line">            ++c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function">string <span class="title">ByteStream::peek_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">min</span>(len, <span class="built_in">buffer_size</span>());</span><br><span class="line">    string s;</span><br><span class="line">    s.<span class="built_in">assign</span>(_buf.<span class="built_in">begin</span>(), _buf.<span class="built_in">begin</span>() + l);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> l = <span class="built_in">min</span>(len, <span class="built_in">buffer_size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; l; ++i)</span><br><span class="line">        _buf.<span class="built_in">pop_front</span>();</span><br><span class="line">    read_ptr += l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next &quot;len&quot; bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function">std::string <span class="title">ByteStream::read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    string r = <span class="built_in">peek_output</span>(len);</span><br><span class="line">    <span class="built_in">pop_output</span>(len);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; end = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> end; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _buf.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _buf.<span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// When the reader has read to the end of the stream, it will reach &quot;EOF&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">input_ended</span>() &amp;&amp; <span class="built_in">buffer_empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> write_ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> read_ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> capacity - _buf.<span class="built_in">size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<ul>
<li><p>使用双端队列<code>std::deque</code>模拟buffer</p></li>
<li><p><code>read</code>方法的实现依赖于<code>peek_output</code>和<code>pop_output</code></p></li>
<li><p><code>peek</code>时需要使用<code>assign</code>方法将字符从<code>std::deque</code>拷贝到<code>std::string</code>中</p></li>
</ul>
<h2 id="streamreassembler类"><code>StreamReassembler</code>类</h2>
<h3 id="功能设计-1">功能设计</h3>
<ul>
<li>提取TCP报文段的有效载荷，将其重组为有序的字节流</li>
<li>TCP发送方将字节流放入多个TCP报文段中，最终封装进IP数据报中传输，但由于网络层提供不可靠服务，因此IP数据报可能乱序、丢失或重复，为此TCP接收方必须将报文段重组为有序的连续字节流</li>
<li><code>StreamReassembler</code>类接收一串字节，首字节的序号，并在合适的时候将字节送入一个<code>ByteStream</code>对象（因此<code>StreamReassembler</code>作为该<code>ByteStream</code>的写进程，上层的应用程序作为该<code>ByteStream</code>的读进程）</li>
</ul>
<h3 id="成员设计-1">成员设计</h3>
<ul>
<li><p>数据成员</p>
<ul>
<li><p><code>capacity</code>表示<code>StreamReassembler</code>缓存区的容量</p></li>
<li><p><code>output</code>是所拥有的<code>ByteStream</code>对象</p></li>
<li><p><code>expected_index</code>表示下一个要写入<code>ByteStream</code>对象的字节的序号</p></li>
<li><p><code>eof_index</code>标记文件结尾对应的序号，当<code>expected_index</code>达到<code>eof_index</code>时，调用<code>ByteStream</code>的<code>end_input()</code>告知已经到达了文件结尾</p></li>
</ul></li>
<li><p>成员函数</p>
<ul>
<li><code>push_string(const string&amp;, const uint64, const bool)</code>，将字符串写入<code>ByteStream</code>对象，<strong>序号</strong>为字符串<strong>第一个字节</strong>在字节流中的序号，EOF标志为真代表到达<strong>文件结尾</strong></li>
<li><code>stream_out()</code>返回<code>StreamReassembler</code>拥有的<code>ByteStream</code>对象，该接口用于更上层的数据结构访问底层的<code>ByteStream</code></li>
<li><code>unassembled_bytes()</code>返回<code>StreamReassembler</code>接收到但未送入<code>ByteStream</code>的字节数，实际上就是<code>StreamReassembler</code>类缓存区的字节数</li>
<li><code>empty()</code>返回缓存区是否为空</li>
</ul></li>
</ul>
<h3 id="关键问题分析-1">关键问题分析</h3>
<ul>
<li><p><code>StreamReassembler</code>类的容量<code>capacity</code>的含义是什么？</p>
<ul>
<li><p>此处我们将<code>ByteStream</code>类的缓存区也视为<code>StreamReassembler</code>缓存区的容量，因为<code>StreamReassembler</code>
“has-A”
<code>ByteStream</code>，所以计算当前缓存区大小时需要同时考虑<code>ByteStream</code>和<code>StreamReassembler</code>对象的缓存区</p></li>
<li><p>故剩余容量<span class="math inline">\(rc\)</span>为 <span class="math display">\[
rc=c-ByteStreamBufferSize-StreamReassemblerBufferSize
\]</span></p></li>
<li><p><code>remain_capacity = capaicity-ByteStream.bufSize-StreamReassembler.bufSize</code></p></li>
<li><p>超出该容量的字节将被直接丢弃。特别地，这里采取的措施是根据当前被上层应用程序读取的最后一个字节的序号<code>lastRead</code>计算出我们能<strong>存储的最大字节序号</strong><code>lastRead+capacity</code>，而对于超出该序号的字节我们将直接<strong>丢弃（即使此时缓存区未满）</strong></p></li>
<li><p>上一点所描述的策略，其实是由于TCP的<strong>流量控制</strong>策略决定的，因为它要求在双方传输TCP报文段时，接收方在<strong>接收窗口字段</strong>提供窗口大小，而该窗口大小是由接收方的缓存区减去当前已写入而未读取的字节数求得的，发送方将根据该窗口大小<code>rwnd</code>调整自己的发送速率，发送方只会允许最多<code>rwnd</code>个已发送而未确认的字节。当接收窗口为零时，发送方发出去的数据就无法被接收（实际上，为了维持正常通信，发送方仍然会发送带有一个字节数据的TCP报文段，其目的主要是为了获取接收方的接收窗口信息更新，这里涉及TCP连接的机制）</p></li>
</ul></li>
<li><p>如何处理收到的字符串<strong>重复、乱序</strong>等的问题？</p>
<ul>
<li><code>StreamReassembler</code>类在一个<strong>有序结构</strong>里面存储字节，如果使用<code>std::map</code>则解决了重复和乱序的问题</li>
<li>对于字节<strong>丢失</strong>的问题，由于TCP提供<strong>可靠数据传输</strong>，超时重传机制保证了数据最终交付，因此<code>StreamReassembler</code>认为所有字节都会到达</li>
</ul></li>
</ul>
<h3 id="数据结构与算法设计-1">数据结构与算法设计</h3>
<ul>
<li><code>StreamReassembler</code>类采用<code>std::map</code>，分析可见上述关键问题分析第二点</li>
</ul>
<h3 id="类定义-1">类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! \brief A class that assembles a series of excerpts from a byte stream (possibly out of order,</span></span><br><span class="line"><span class="comment">//! possibly overlapping) into an in-order byte stream.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StreamReassembler</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    ByteStream _output;  <span class="comment">//!&lt; The reassembled in-order byte stream</span></span><br><span class="line">    <span class="keyword">size_t</span> _capacity;    <span class="comment">//!&lt; The maximum number of bytes</span></span><br><span class="line">    map&lt;<span class="keyword">size_t</span>, <span class="keyword">char</span>&gt; _buf;</span><br><span class="line">    <span class="keyword">size_t</span> _expected_index;</span><br><span class="line">    <span class="keyword">size_t</span> _eof_index;</span><br><span class="line">    <span class="keyword">bool</span> _eof_flag;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员实现-1">成员实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;stream_reassembler.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a stream reassembler.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 1, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab1`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You will need to add private members to the class declaration in `stream_reassembler.hh`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">StreamReassembler::<span class="built_in">StreamReassembler</span>(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity) : _output(capacity), _capacity(capacity), _buf(&#123;&#125;), _expected_index(<span class="number">0</span>), _eof_index(<span class="number">0</span>), _eof_flag(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \details This function accepts a substring (aka a segment) of bytes,</span></span><br><span class="line"><span class="comment">//! possibly out-of-order, from the logical stream, and assembles any newly</span></span><br><span class="line"><span class="comment">//! contiguous substrings and writes them into the output stream in order.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StreamReassembler::push_substring</span><span class="params">(<span class="keyword">const</span> string &amp;data, <span class="keyword">const</span> <span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">bool</span> eof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eof) &#123;</span><br><span class="line">        _eof_index = index + data.<span class="built_in">size</span>();</span><br><span class="line">        _eof_flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push bytes into StreamReassembler buffer</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i + index &gt;= _expected_index &amp;&amp; i + index &lt; _expected_index + _capacity - _output.<span class="built_in">buffer_size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_buf.<span class="built_in">count</span>(index + i) == <span class="number">0</span>) &#123;</span><br><span class="line">                _buf[index + i] = data[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push bytes into ByteStream buffer, if the expected byte exists</span></span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (!_buf.<span class="built_in">empty</span>() &amp;&amp; _buf.<span class="built_in">begin</span>()-&gt;first == _expected_index) &#123;</span><br><span class="line">        s += _buf.<span class="built_in">begin</span>()-&gt;second;</span><br><span class="line">        ++_expected_index;</span><br><span class="line">        _buf.<span class="built_in">erase</span>(_buf.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (_eof_flag &amp;&amp; _expected_index == _eof_index)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _output.<span class="built_in">write</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (_eof_flag &amp;&amp; _eof_index == _expected_index) &#123;</span><br><span class="line">        _output.<span class="built_in">end_input</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">StreamReassembler::unassembled_bytes</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _buf.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StreamReassembler::empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _buf.<span class="built_in">empty</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1">总结</h3>
<ul>
<li><p><code>StreamReassembler</code>存储的字节序号<span class="math inline">\(i\)</span>必须满足 <span class="math display">\[
expectedIndex \leq i \lt expectedIndex + capacity - ByteStreamBufferSize
\]</span></p></li>
<li><p>EOF检测问题</p>
<ul>
<li>当<code>push_string</code>的<code>eof</code>标志位置位时，我们必须保存对应的<code>eof_index</code>，其含义是当<code>expected_index==eof_index</code>时到达了文件结尾</li>
<li>假如我们向<code>ByteStream</code>写入一个字节后<code>expected_index</code>到达了<code>eof_index</code>，代表我们已到达了文件结尾，不会再写入任何其他字节，此时调用<code>ByteStream</code>对象的<code>end_input()</code>方法告知文件结尾</li>
<li>特别地，如果我们不写入任何字节就到达了文件结尾，则我们的<code>eof_index</code>是0，与<code>expected_index</code>初始值是0。这意味着，我们不能把EOF检测的代码段放在将字节写入缓存区的循环中，否则上述情况将无法检测到EOF（没有任何字节要写入缓存区）</li>
<li>同样地，由于上述问题，<code>eof_index</code>的初始值难以设定，除非将其类型设为有符号数并把初始值设为-1。此外，我们可以额外设置一个<code>eof_flag</code>，初始置为false，当到达文件结尾时置位。进行EOF检测时，必须同时满足<code>eof_flag&amp;&amp;expected_index==eof_index</code></li>
</ul></li>
</ul>
<h2 id="tcp-receiver类"><code>TCP Receiver</code>类</h2>
<h3 id="工具函数字节编号之间的转换">工具函数：字节编号之间的转换</h3>
<ul>
<li><p>对于字节的<strong>编号</strong>存在<strong>三种类型</strong>，分别是<strong>字节流编号stream
index</strong>、TCP报文段中的<strong>序号seqno</strong>、<strong>绝对序号absolute
seqno</strong>，TCP接收方需要编写<strong>工具函数</strong>，实现三者之间的相互<strong>转换</strong></p>
<ul>
<li><code>StreamReassembler</code>中的某个字节都有一个<strong>64位的stream
index</strong>，该下标<strong>从零开始</strong>，不断递增</li>
<li>在TCP报文段中，每个字节的下标是用<strong>32位的seqno</strong>表示的。由于32位能表示的范围较小，因此<strong>seqno循环使用</strong>。为了安全性，seqno随机指定<strong>初始序号ISN</strong>，后面的报文段在该ISN的基础上循环递增。TCP传输的<strong>SYN报文段</strong>和<strong>FIN报文段</strong>也<strong>占用一个seqno</strong></li>
<li>绝对序号，64位的absolute
seqno。从0开始，不循环使用。TCP传输的<strong>SYN报文段</strong>和<strong>FIN报文段</strong>也<strong>占用一个absolute
seqno</strong>；与之相对的，<strong>stream
index</strong>只对有效字节编号</li>
</ul></li>
<li><p>absolute seqno与stream index之间的转换，只考虑有效字节 <span class="math display">\[
absolute\ seqno-1 = stream \ index
\]</span></p></li>
<li><p>absolute seqno与seqno之间的转换</p></li>
</ul>
<h3 id="功能设计-2">功能设计</h3>
<ul>
<li>实现TCP的接收方，从接收的TCP报文段提取数据，并转换为字节流输入<code>StreamReassembler</code>中</li>
<li>此外，TCP接收方还需要告诉发送方两个信息，以实现<strong>流量控制</strong>
<ul>
<li><strong>最小的未重组的字节的序号</strong>，也叫做<strong>确认号</strong><code>ackno</code>，它代表当前接收方希望收到的第一个字节</li>
<li><strong>接收窗口</strong>，这是第一个未重组的字节序号到第一个未接收的字节序号之间的大小</li>
</ul></li>
</ul>
<h3 id="成员设计-2">成员设计</h3>
<ul>
<li><strong>数据成员</strong>
<ul>
<li><code>capacity</code>，<code>TCPReceiver</code>的容量，本质上就是<code>StreamReassembler</code>的容量</li>
<li><code>isn</code>，存储由发送方随机指定的TCP连接的初始序号</li>
<li><code>eof</code>，当接收到发送方的FIN报文段时，意味着到达文件结尾，不会有更多数据到来</li>
<li><code>reassembler</code>，接收方所拥有的底层<code>StreamReassembler</code>对象</li>
<li><code>checkpoint</code>，用于进行absolute
seqno到seqno转换的特殊成员，这种转换会<strong>将seqno转换到离checkpoint最近的absolute
seqno</strong>，保证了转换的结果唯一，总是<strong>将当前重组的最后一个字节的absolute
seqno作为最新的checkpoint</strong></li>
</ul></li>
<li><strong>成员函数</strong>
<ul>
<li><code>segment_received(const TCPSegment&amp;)</code>，<strong>接收</strong>一个<strong>TCP报文段</strong>，需要将其中的数据送入<code>StreamReassembler</code></li>
<li><code>ackno()</code>，计算并返回确认号</li>
<li><code>window_size()</code>，计算并返回接收窗口</li>
<li><code>unassembled_bytes()</code>，计算并返回已接受当未确认的字节数</li>
<li><code>stream_out()</code>，获取<code>TCPReceiver</code>所拥有的（<code>StreamReassembler</code>所拥有的）<code>ByteStream</code>的接口</li>
</ul></li>
</ul>
<h3 id="关键问题分析-2">关键问题分析</h3>
<ul>
<li>实现<code>TCPReceiver</code>并不涉及复杂的算法，但是细节较多。关键在于seqno与absolute
seqno与stream
index之间的<strong>转换关系</strong>，需要注意的点是它们<strong>是否考虑SYN标志位、FIN标志位</strong>以及它们之间的影响</li>
<li><code>segment_received</code>
<ul>
<li>若接收到<strong>SYN报文段</strong>，需要<strong>记录ISN</strong></li>
<li>将TCP报文段数据的首个字节的序号seqno转换为stream
index（先将其转换为<strong>absolute
seqno</strong>，然后考虑SYN标志位<strong>再减1</strong>）</li>
<li>调用<code>push_substring</code>将该字符串送入<code>StreamReassembler</code>对象</li>
</ul></li>
<li><code>ackno</code>
<ul>
<li>首先获取该字节的<code>stream index</code>，即<code>StreamReassembler</code>中的<code>expected_index</code>，但由于它是private成员，我们无法直接获取。可以通过<code>ByteStream</code>中的<code>bytes_written</code>获得，该值就是期望写入的下一个字节的stream
index</li>
<li>将该值转换为absolute seqno时，考虑SYN报文段，因此加1</li>
<li>特别地，我们还需要考虑FIN报文段，而FIN报文段被确认的标志就是<code>StreamReassembler</code>检测到文件结尾，并调用<code>ByteStream</code>的<code>end_input</code>方法，因此我们可以通过<code>ByteStream</code>的<code>input_ended()</code>判断FIN报文段是否被确认，如确认则再加1，从而获得absolute
seqno</li>
<li>最后将其转换为seqno并返回</li>
</ul></li>
<li><code>window_size</code>
<ul>
<li>根据TCP流量控制的相关定义，该值等于容量将去<code>ByteStream</code>缓存区中的字节数，它代表着TCP发送方允许发送但未确认的最多字节数，也代表着<code>StreamReassembler</code>缓存区中允许的最多字节数</li>
</ul></li>
</ul>
<h3 id="数据结构与算法设计-2">数据结构与算法设计</h3>
<ul>
<li><code>TCPReceiver</code>类没有使用特殊数据结构，依赖于<code>StreamReassembler</code>类实现字节流的重组</li>
</ul>
<h3 id="类定义-2">类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPReceiver</span> &#123;</span></span><br><span class="line">    <span class="comment">//! Our data structure for re-assembling bytes.</span></span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! The maximum number of bytes we&#x27;ll store.</span></span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line"></span><br><span class="line">    std::optional&lt;WrappingInt32&gt; _isn = nullopt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> _checkpoint = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员实现-2">成员实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_receiver.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP receiver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 2, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab2`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// set the ISN if necessary</span></span><br><span class="line">    WrappingInt32 seqno = seg.<span class="built_in">header</span>().seqno;</span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">        _isn = seqno;</span><br><span class="line">        seqno = seqno + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// push any data, or eof to the StreamReassembler</span></span><br><span class="line">    <span class="keyword">if</span> (_isn) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> index = <span class="built_in">unwrap</span>(seqno, _isn.<span class="built_in">value</span>(), _checkpoint) - <span class="number">1</span>;</span><br><span class="line">        _checkpoint = index;</span><br><span class="line">        _reassembler.<span class="built_in">push_substring</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> std::string&gt;(seg.<span class="built_in">payload</span>().<span class="built_in">str</span>()), index, seg.<span class="built_in">header</span>().fin);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!_isn)</span><br><span class="line">        <span class="keyword">return</span> nullopt;</span><br><span class="line">    <span class="comment">// considering syn flag</span></span><br><span class="line">    <span class="keyword">uint64_t</span> index = <span class="built_in">stream_out</span>().<span class="built_in">bytes_written</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// considering fin flag</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stream_out</span>().<span class="built_in">input_ended</span>())</span><br><span class="line">        ++index;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">wrap</span>(index, _isn.<span class="built_in">value</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _capacity - <span class="built_in">stream_out</span>().<span class="built_in">buffer_size</span>(); &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-2">总结</h3>
<ul>
<li><code>ackno</code>的特殊情况，当我们确认服务端FIN报文段时，仍然需要返回一个ack（第四次挥手），而此时的<code>seqno</code>需要<strong>同时考虑<code>SYN</code>和<code>FIN</code></strong>，因此我们把<strong>下一个字节的<code>stream index</code>加二才得到了对应的<code>absolute seqno</code></strong></li>
</ul>
<h2 id="tcp-sender类"><code>TCP Sender</code>类</h2>
<p>### 功能设计</p>
<ul>
<li>TCP发送方，从<code>ByteStream</code>对象读取上层应用程序传输的<strong>字节</strong>，封装成<strong>TCP报文段</strong>并<strong>发送</strong></li>
<li>只要<code>ByteStream</code>中有上层应用程序写入的字节，且接收窗口非空，则发送TCP报文段</li>
<li>缓存<strong>已发送未确认</strong>的TCP报文段</li>
<li>如果TCP报文段一定时间内没有得到确认（<strong>超时</strong>），则<strong>重传</strong></li>
</ul>
<h3 id="成员设计-3">成员设计</h3>
<ul>
<li>略</li>
</ul>
<h3 id="关键问题分析-3">关键问题分析</h3>
<ul>
<li><strong>重传计时器</strong>的实现
<ul>
<li>其重传超时间隔<code>RTO</code>是变量，而重传超时间隔初始值<code>RTO_initial</code>是常量</li>
<li>当TCP发送端发送一个TCP报文段前（非重传），或收到ACK，会把<code>RTO</code><strong>重设</strong>为<code>RTO_initial</code></li>
<li>当重传计时器<strong>超时</strong>，则<code>RTO</code><strong>加倍</strong>，并重传当缓存中的第一个未确认TCP报文段</li>
<li>每当<strong>发送</strong>一个TCP报文段时，如果计时器未启动，则<strong>启动计时器</strong></li>
<li>当接收到一个ACK后，如果输出缓冲中没有报文段，即所有发送的报文段都确认了，则<strong>停止计时器</strong></li>
</ul></li>
<li>根据<code>ByteStream</code>和<strong>接收窗口</strong>的情况决定<strong>发送报文段</strong>
<ul>
<li>如果当前窗口还有空位（<code>window_size-bytes_in_flight()&gt;0</code>），则<strong>发送TCP数据报</strong>，有三种情况
<ul>
<li><strong>SYN报文段</strong>：如果<code>next_seqno</code>为0说明还未发送任何报文段，此时应该先发送SYN报文段）</li>
<li><strong>普通报文段</strong>：尽可能多（不超出<code>TCPConfig::MAX_PAYLOAD_SIZE</code>，理论上当TCP首部、IP数据报首部不包含选项字段时均为<strong>20字节</strong>，故该值为<strong>1460字节</strong>，因为以太网帧的数据字段上限为<strong>1500字节</strong>）地从<code>ByteStream</code>中读取数据并发送</li>
<li><strong>FIN报文段</strong>：如果<code>ByteStream</code>处于<code>input_ended()</code>状态并且缓存中的字节已全部读出则标志着文件结尾，此时可以发送FIN报文段</li>
</ul></li>
<li>将数据放入报文段后，调用<code>TCPSegment</code>类的<code>length_in_sequence_space()</code>方法获取TCP数据报的字节数，并更新<code>next_seqno</code>，然后将该数据报<strong>发送</strong>并<strong>放入输出缓存</strong></li>
<li>如果计时器未启动则<strong>启动计时器</strong></li>
</ul></li>
<li><strong>收到ACK</strong>时的行为
<ul>
<li>将<code>ackno</code>转换为absolute
seqno，如果是<strong>新的</strong><code>ackno</code>则需要</li>
<li>更新发送方保存的<code>ackno</code></li>
<li>重设重传计时器的<strong><code>RTO</code>为初始值</strong></li>
<li>从输出缓存中将<strong>已确认的报文段弹出</strong></li>
<li>检查缓存区是否还有未确认报文段，若有则<strong>重启计时器</strong>，否则<strong>停止计时器</strong></li>
</ul></li>
<li>如果收到ACK中的接<strong>收窗口是0，如何处理？</strong>
<ul>
<li>如果接收窗口为0，从理论上分析我们不应该发送任何TCP报文段</li>
<li>倘若我们不发送任何TCP报文段且当前所有发送的报文段都已确认，则此后我们可能无法收到任何接收方的报文，这样即使接收方的应用程序从<code>ByteStream</code>读取数据使得接收窗口大小重新变为非0，我们也无法得知该信息</li>
<li>根据上述分析，若<strong>接收窗口为0</strong>，我们会发送一个<strong>带有1字节数据的TCP报文段</strong>。该TCP报文段的主要作用从返回的报文中<strong>获取窗口信息</strong></li>
</ul></li>
</ul>
<h3 id="数据结构与算法设计-3">数据结构与算法设计</h3>
<ul>
<li>不涉及任何数据结构，因为大部分的工作已经在<code>ByteStream</code>中完成</li>
<li>需要设计重传计时器<code>RetransmissionTimer</code>类，主要涉及时间的更新，以及对<code>RTO</code>的更新</li>
</ul>
<h3 id="类定义-3">类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetransmissionTimer</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> RTO_;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> RTO_initial_;</span><br><span class="line">    <span class="keyword">size_t</span> cur_;</span><br><span class="line">    <span class="keyword">bool</span> running_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// check if expire happened</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getAlarm_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RetransmissionTimer</span>(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> RTO);</span><br><span class="line">    <span class="comment">// reset the timer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// restart the timer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">restart</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// start at a certain time</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// stop the timer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// update current time, check if expire happened</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">update</span><span class="params">(<span class="keyword">size_t</span> time)</span></span>;</span><br><span class="line">    <span class="comment">// reset RTO</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetRTO</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// double RTO</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doubleRTO</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSender</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! our initial sequence number, the number for our SYN.</span></span><br><span class="line">    WrappingInt32 isn_;</span><br><span class="line">    <span class="comment">//! outbound queue of segments that the TCPSender wants sent</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; segments_out_&#123;&#125;;</span><br><span class="line">    <span class="comment">//! retransmission timer for the connection</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> initial_retransmission_timeout_;</span><br><span class="line">    <span class="comment">//! outgoing stream of bytes that have not yet been sent</span></span><br><span class="line">    ByteStream stream_;</span><br><span class="line">    <span class="comment">//! the (absolute) sequence number for the next byte to be sent</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next_seqno_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//! the outstanding data structure</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; outstanding_&#123;&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> window_size_ = <span class="number">1</span>;</span><br><span class="line">    RetransmissionTimer timer_;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> retransmissions_cnt_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> ackno_ = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset_consecutive_retransmissions_</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> bytes_cnt_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> fin_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员实现-3">成员实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_sender.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_config.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP sender</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 3, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab3`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] capacity the capacity of the outgoing byte stream</span></span><br><span class="line"><span class="comment">//! \param[in] retx_timeout the initial amount of time to wait before retransmitting the oldest outstanding segment</span></span><br><span class="line"><span class="comment">//! \param[in] fixed_isn the Initial Sequence Number to use, if set (otherwise uses a random ISN)</span></span><br><span class="line">TCPSender::<span class="built_in">TCPSender</span>(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity, <span class="keyword">const</span> <span class="keyword">uint16_t</span> retx_timeout, <span class="keyword">const</span> std::optional&lt;WrappingInt32&gt; fixed_isn)</span><br><span class="line">    : <span class="built_in">isn_</span>(fixed_isn.<span class="built_in">value_or</span>(WrappingInt32&#123;<span class="built_in">random_device</span>()()&#125;))</span><br><span class="line">    , initial_retransmission_timeout_&#123;retx_timeout&#125;</span><br><span class="line">    , <span class="built_in">stream_</span>(capacity)</span><br><span class="line">    , <span class="built_in">timer_</span>(retx_timeout) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> next_seqno_ - ackno_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// make each individual TCPSegment as big as possible</span></span><br><span class="line">    <span class="keyword">size_t</span> size;;</span><br><span class="line">    <span class="keyword">while</span> (!fin_ &amp;&amp; (size = (window_size_? window_size_: <span class="number">1</span>) - <span class="built_in">bytes_in_flight</span>())) &#123;</span><br><span class="line">        TCPSegment seg = <span class="built_in">TCPSegment</span>();</span><br><span class="line">        <span class="comment">// SYN segment doesn&#x27;t carry data</span></span><br><span class="line">        <span class="keyword">if</span> (next_seqno_ == <span class="number">0</span>) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().syn = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            string payload = stream_.<span class="built_in">read</span>(<span class="built_in">min</span>(size, TCPConfig::MAX_PAYLOAD_SIZE));</span><br><span class="line">            seg.<span class="built_in">payload</span>() = <span class="built_in">Buffer</span>(std::<span class="built_in">move</span>(payload));</span><br><span class="line">            size -= seg.<span class="built_in">payload</span>().<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// FIN segment doesn&#x27;t carry data</span></span><br><span class="line">            <span class="keyword">if</span> (size &amp;&amp; payload.<span class="built_in">size</span>() == <span class="number">0</span> &amp;&amp; stream_.<span class="built_in">buffer_empty</span>() &amp;&amp; stream_.<span class="built_in">input_ended</span>()) &#123;</span><br><span class="line">                seg.<span class="built_in">header</span>().fin = <span class="literal">true</span>;</span><br><span class="line">                fin_ = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">            seg.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(next_seqno_, isn_);</span><br><span class="line">            next_seqno_ += seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            outstanding_.<span class="built_in">push</span>(seg);</span><br><span class="line">            segments_out_.<span class="built_in">push</span>(seg);</span><br><span class="line">            bytes_cnt_ += seg.<span class="built_in">length_in_sequence_space</span>();</span><br><span class="line">            timer_.<span class="built_in">start</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param ackno The remote receiver&#x27;s ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver&#x27;s advertised window size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> seqno = <span class="built_in">unwrap</span>(ackno, isn_, next_seqno_);</span><br><span class="line">    <span class="comment">// impossible ackno is ignored</span></span><br><span class="line">    <span class="keyword">if</span> (seqno &gt; next_seqno_)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    window_size_ = window_size;</span><br><span class="line">    <span class="keyword">if</span> (seqno &gt; ackno_) &#123;</span><br><span class="line">        timer_.<span class="built_in">resetRTO</span>();</span><br><span class="line">        timer_.<span class="built_in">restart</span>();</span><br><span class="line">        <span class="built_in">reset_consecutive_retransmissions_</span>();</span><br><span class="line">        ackno_ = seqno;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (outstanding_.<span class="built_in">empty</span>())</span><br><span class="line">        timer_.<span class="built_in">stop</span>();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// lookup outstanding and pop the acknowledged segments</span></span><br><span class="line">        <span class="keyword">while</span> (!outstanding_.<span class="built_in">empty</span>() &amp;&amp; seqno &gt;= <span class="built_in">unwrap</span>(outstanding_.<span class="built_in">front</span>().<span class="built_in">header</span>().seqno, isn_, next_seqno_) +</span><br><span class="line">                                                     outstanding_.<span class="built_in">front</span>().<span class="built_in">length_in_sequence_space</span>()) &#123;</span><br><span class="line">            outstanding_.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// retransmit</span></span><br><span class="line">    <span class="keyword">if</span> (timer_.<span class="built_in">update</span>(ms_since_last_tick) &amp;&amp; !outstanding_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TCPSegment seg = outstanding_.<span class="built_in">front</span>();</span><br><span class="line">        segments_out_.<span class="built_in">push</span>(seg);</span><br><span class="line">        <span class="keyword">if</span> (window_size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            retransmissions_cnt_++;</span><br><span class="line">            timer_.<span class="built_in">doubleRTO</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// reset and start with a doubled RTO</span></span><br><span class="line">        timer_.<span class="built_in">restart</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> retransmissions_cnt_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::reset_consecutive_retransmissions_</span><span class="params">()</span> </span>&#123; retransmissions_cnt_ = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment seg = <span class="built_in">TCPSegment</span>();</span><br><span class="line">    <span class="comment">// Dont update _next_seqno</span></span><br><span class="line">    seg.<span class="built_in">header</span>().seqno = <span class="built_in">wrap</span>(next_seqno_, isn_);</span><br><span class="line">    segments_out_.<span class="built_in">push</span>(seg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] RTO the initial value of RTO</span></span><br><span class="line">RetransmissionTimer::<span class="built_in">RetransmissionTimer</span>(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> RTO) : RTO_&#123;RTO&#125;, RTO_initial_&#123;RTO&#125;, cur_&#123;<span class="number">0</span>&#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RetransmissionTimer::reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    running_ = <span class="literal">false</span>;</span><br><span class="line">    cur_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RetransmissionTimer::restart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    running_ = <span class="literal">true</span>;</span><br><span class="line">    cur_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// RetransmissionTimer can start at a certain time</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RetransmissionTimer::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!running_) &#123;</span><br><span class="line">        running_ = <span class="literal">true</span>;</span><br><span class="line">        cur_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RetransmissionTimer::update</span><span class="params">(<span class="keyword">size_t</span> time)</span> </span>&#123;</span><br><span class="line">    cur_ += time;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getAlarm_</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// resset RTO</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RetransmissionTimer::resetRTO</span><span class="params">()</span> </span>&#123; RTO_ = RTO_initial_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// double RTO</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RetransmissionTimer::doubleRTO</span><span class="params">()</span> </span>&#123; RTO_ *= <span class="number">2</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check if expire happend</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">RetransmissionTimer::getAlarm_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> running_ &amp;&amp; cur_ &gt;= RTO_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stop the timer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RetransmissionTimer::stop</span><span class="params">()</span> </span>&#123; running_ = <span class="literal">false</span>; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3">总结</h3>
<ul>
<li><strong>发送新的TCP报文段的行为</strong></li>
<li><strong>收到ACK时的行为</strong></li>
<li><strong>对于重传计时器的管理</strong></li>
<li><strong>当接收窗口为0时的行为</strong></li>
</ul>
<h2 id="tcp-connection类"><code>TCP Connection</code>类</h2>
<h3 id="功能设计-3">功能设计</h3>
<ul>
<li>将已实现的<code>TCP Receiver</code>类和<code>TCP Sender</code>类组合称为<code>TCP Connection</code>类，使其具备TCP的基本功能，并将其用于与实际因特网进行通信</li>
<li>当<code>TCP Connection</code>类<strong>接收TCP报文段</strong>时，它会
<ul>
<li>如果RST标志位置位，则将输入流和输出流都设置为错误状态，并终止连接</li>
<li>否则，将报文段传递给<code>TCP Receiver</code>处理</li>
<li>如果<code>ACK</code>标志位置位，将<code>ackno</code>和<code>window_size</code>告诉<code>TCP Sender</code></li>
<li>如果报文段占据了至少一个seqno（即并非空报文段），则<code>TCP Connection</code>至少应该返回一条报文段，以反映自己ackno和window
size的变化情况</li>
<li>可能收到一种特殊的报文段：<strong>keep-alive报文段</strong>，此时无论它是否携带有效数据，都应该发送一条空报文段以告知本节点仍处于活跃状态</li>
</ul></li>
<li>当<code>TCP Connection</code>类<strong>发送报文段</strong>时，它会
<ul>
<li>在发送前通过<code>TCP Receiver</code>获取ackno和接收窗口信息，在报文段设置相应字段，并将<code>ACK</code>标志位置位</li>
</ul></li>
<li>操作系统将定时调用<code>TCP Connection</code>类的<code>tick</code>方法以告知当前的时间
<ul>
<li>调用<code>TCP Sender</code>的<code>tick</code>方法以告知其当前时间</li>
<li>如果<strong>连续重传次数</strong>超过了<code>TCPConfig::MAX_RETX_ATTEMPTS</code>，则中止连接并发送<strong>reset报文段</strong>给对等方（RST标志位置位的空报文段）</li>
<li><strong>end the connection cleanly</strong> if necessary</li>
</ul></li>
</ul>
<h3 id="成员设计-4">成员设计</h3>
<ul>
<li><code>connect()</code>，发送SYN报文段，通过三次握手建立TCP连接</li>
<li><code>write(const string&amp;)</code>，由上层的应用程序调用，将数据写入并通过TCP连接发送</li>
<li><code>remaining_outbound_capacity()</code>，当前可以写入的字节数量</li>
<li><code>end_input_stream()</code>，终止输出<code>ByteStream</code>（但仍然可以接收数据）</li>
<li><code>inbound_stream()</code>，接收到的数据写入<code>ByteStream</code>对象的接口</li>
<li><code>bytes_in_flight()</code>，已发送未确认的字节数</li>
<li><code>unassembled_bytes()</code>，收到但是未重组的字节数，等于<code>StreamReassembler</code>缓存区的字节数</li>
<li><code>time_since_last_segment_received()</code>，从收到上个TCP报文段后经过的毫秒数</li>
<li><code>state()</code>，返回<code>TCPSender</code>、<code>TCPReceiver</code>和<code>TCPConnection</code>对象</li>
</ul>
<h3 id="关键问题分析-4">关键问题分析</h3>
<ul>
<li><p><strong>收到或发送RST报文段</strong>后进行什么操作？</p>
<ul>
<li>将inbound和outbound的<code>ByteStream</code>对象设置为错误状态</li>
<li>活跃标志<code>active</code>置为false，<strong>直接中止当前TCP连接</strong></li>
</ul></li>
<li><p>什么时候主动<strong>发送RST报文段</strong>？</p>
<ul>
<li>当连续<strong>重传次数超过了上限值</strong>时</li>
<li>当<code>TCPConnection</code>的<strong>析构函数</strong>被调用，而此时还处于<code>active</code>状态时</li>
</ul></li>
<li><p>什么时候<strong>发送空报文段</strong>？</p>
<ul>
<li>当TCP必须发送一条报文段，而又没有数据要发送时，则发送空报文段</li>
<li>必须<strong>收到一条包含数据的报文段</strong>，则必须<strong>告诉对方ackno和window
size</strong>信息</li>
</ul></li>
<li><p>什么时候<strong>终止TCP连接</strong>？如何终止TCP连接？</p>
<ul>
<li><p>根据<code>TCP Sender</code>类中的分析，当上层应用程序以到达文件结尾，且缓存区的所有数据都已发送并确认，则发送FIN报文段请求终止TCP连接</p></li>
<li><p>TCP连接断开时要执行四次挥手，具体地</p>
<ul>
<li>A向B发送FIN报文段</li>
<li>B向A发送对FIN报文段的确认</li>
<li>B（将输出缓存的所有数据发送并确认后）向A发送FIN报文段</li>
<li>A向B发送对FIN报文段的确认</li>
</ul></li>
<li><p>执行完上述过程后，对于B</p>
<ul>
<li>如果它收到了A的确认，则可以立刻断开TCP连接</li>
<li>如果没收到，则超时重传FIN报文段</li>
</ul></li>
<li><p>根据上述分析，可知A无法直接中止连接，因为它必须确定B收到了自己对FIN报文段的确认，A应该如何确定呢？</p>
<ul>
<li><strong>等待10倍<code>RTO</code>时间</strong>，如果没收到B重传的FIN报文段，则认为B已经收到了自己的ACK，中止TCP连接</li>
</ul>
<blockquote>
<p>实践中我们等待<strong>2倍的MSL (Maximum Segment
Life)</strong>，是任何报文在网络上存在的最长时间，因为B收到自己的ACK最多经历1MSL，而B重传FIN报文段到达A最多再经历1MSL，因此最长等待时间2MSL。如果仍然未等到，则说明B已经收到ACK并关闭连接了。</p>
</blockquote>
<ul>
<li>若在此过程中<strong>收到了B重传的FIN报文段</strong>，则再次<strong>发送ACK</strong>，并<strong>重新开始计时</strong></li>
</ul></li>
<li><p>上述四次挥手后<strong>A等待的时间称为linger
time</strong></p></li>
<li><p>相反，B收到了A的ACK后无需等待就直接关闭连接，这是因为A是主动发送FIN报文段的一方，因此当B收到它对自己FIN报文段的ACK后就可以<strong>肯定A已经完成了所有数据的传输工作</strong>，因此它直接关闭TCP连接</p></li>
</ul></li>
</ul>
<h3 id="数据结构与算法分析">数据结构与算法分析</h3>
<ul>
<li>不涉及数据结构与算法</li>
</ul>
<h3 id="类定义-4">类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SPONGE_LIBSPONGE_TCP_FACTORED_HH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SPONGE_LIBSPONGE_TCP_FACTORED_HH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_config.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_receiver.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_sender.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_state.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//! \brief A complete endpoint of a TCP connection</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPConnection</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    TCPConfig cfg_;</span><br><span class="line">    TCPReceiver receiver_;</span><br><span class="line">    TCPSender sender_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! outbound queue of segments that the TCPConnection wants sent</span></span><br><span class="line">    std::queue&lt;TCPSegment&gt; segments_out_&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Should the TCPConnection stay active (and keep ACKing)</span></span><br><span class="line">    <span class="comment">//! for 10 * _cfg.rt_timeout milliseconds after both streams have ended,</span></span><br><span class="line">    <span class="comment">//! in case the remote TCPConnection doesn&#x27;t know we&#x27;ve received its whole stream?</span></span><br><span class="line">    <span class="keyword">bool</span> linger_after_streams_finish_&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief read Segments from _sender, push them onto _segments_out, to send them over TCP</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send_</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> rst, <span class="keyword">const</span> <span class="keyword">bool</span> force)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">TCPSegment <span class="title">readSegment_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> now_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> last_recv_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> active_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">checkLinger_</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> syn_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! \name &quot;Input&quot; interface for the writer</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Initiate a connection by sending a SYN segment</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Write data to the outbound byte stream, and send it over TCP if possible</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes from `data` that were actually written.</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> std::string &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the number of `bytes` that can be written right now.</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">remaining_outbound_capacity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Shut down the outbound byte stream (still allows reading incoming data)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end_input_stream</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name &quot;Output&quot; interface for the reader</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief The inbound byte stream received from the peer</span></span><br><span class="line">    <span class="function">ByteStream &amp;<span class="title">inbound_stream</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> receiver_.<span class="built_in">stream_out</span>(); &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name Accessors used for testing</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line">    <span class="comment">//! \brief number of bytes sent and not yet acknowledged, counting SYN/FIN each as one byte</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! \brief number of bytes not yet reassembled</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">unassembled_bytes</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//! \brief Number of milliseconds since the last segment was received</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">time_since_last_segment_received</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//!&lt; \brief summarize the state of the sender, receiver, and the connection</span></span><br><span class="line">    <span class="function">TCPState <span class="title">state</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> &#123;sender_, receiver_, <span class="built_in">active</span>(), linger_after_streams_finish_&#125;; &#125;;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name Methods for the owner or operating system to call</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Called when a new segment has been received from the network</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Called periodically when time elapses</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief TCPSegments that the TCPConnection has enqueued for transmission.</span></span><br><span class="line">    <span class="comment">//! \note The owner or operating system will dequeue these and</span></span><br><span class="line">    <span class="comment">//! put each one into the payload of a lower-layer datagram (usually Internet datagrams (IP),</span></span><br><span class="line">    <span class="comment">//! but could also be user datagrams (UDP) or any other kind).</span></span><br><span class="line">    <span class="function">std::queue&lt;TCPSegment&gt; &amp;<span class="title">segments_out</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> segments_out_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \brief Is the connection still alive in any way?</span></span><br><span class="line">    <span class="comment">//! \returns `true` if either stream is still running or if the TCPConnection is lingering</span></span><br><span class="line">    <span class="comment">//! after both streams have finished (e.g. to ACK retransmissions from the peer)</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">active</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Construct a new connection from a configuration</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">TCPConnection</span><span class="params">(<span class="keyword">const</span> TCPConfig &amp;cfg)</span></span></span><br><span class="line"><span class="function">        : cfg_&#123;</span>cfg&#125;, <span class="built_in">receiver_</span>(cfg.recv_capacity), <span class="built_in">sender_</span>(cfg_.send_capacity, cfg_.rt_timeout, cfg_.fixed_isn) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name construction and destruction</span></span><br><span class="line">    <span class="comment">//! moving is allowed; copying is disallowed; default construction not possible</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line">    ~<span class="built_in">TCPConnection</span>();  <span class="comment">//!&lt; destructor sends a RST if the connection is still open</span></span><br><span class="line">    <span class="built_in">TCPConnection</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">TCPConnection</span>(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    TCPConnection &amp;<span class="keyword">operator</span>=(TCPConnection &amp;&amp;other) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">TCPConnection</span>(<span class="keyword">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    TCPConnection &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> TCPConnection &amp;other) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SPONGE_LIBSPONGE_TCP_FACTORED_HH</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="成员实现-4">成员实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_connection.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a TCP connection</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 4, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check`.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPConnection::remaining_outbound_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sender_.<span class="built_in">stream_in</span>().<span class="built_in">remaining_capacity</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPConnection::bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> sender_.<span class="built_in">bytes_in_flight</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPConnection::unassembled_bytes</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> receiver_.<span class="built_in">unassembled_bytes</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPConnection::time_since_last_segment_received</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> now_ - last_recv_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    last_recv_ = now_;</span><br><span class="line">    <span class="comment">// if the rst (reset) flag is set, sets both the inbound and outbound streams to the error state and kills the</span></span><br><span class="line">    <span class="comment">// connection permanently.</span></span><br><span class="line">    <span class="keyword">if</span> (seg.<span class="built_in">header</span>().rst) &#123;</span><br><span class="line">        sender_.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        receiver_.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        active_ = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver_.<span class="built_in">segment_received</span>(seg);</span><br><span class="line">        <span class="keyword">if</span> (seg.<span class="built_in">header</span>().syn) &#123;</span><br><span class="line">            syn_ = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if the ack flag is set, tells the TCPSender about the fields it cares about on incoming segments: ackno and</span></span><br><span class="line">        <span class="comment">// window size.</span></span><br><span class="line">        <span class="keyword">if</span> (seg.<span class="built_in">header</span>().ack) &#123;</span><br><span class="line">            sender_.<span class="built_in">ack_received</span>(seg.<span class="built_in">header</span>().ackno, seg.<span class="built_in">header</span>().win);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if the incoming segment occupied any sequence numbers, the TCPConnection makes sure</span></span><br><span class="line">        <span class="comment">// that at least one segment is sent in reply, to react an update in the ackno and window size.</span></span><br><span class="line">        <span class="keyword">if</span> (seg.<span class="built_in">length_in_sequence_space</span>() &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">send_</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (receiver_.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>() &amp;&amp; seg.<span class="built_in">header</span>().seqno == receiver_.<span class="built_in">ackno</span>().<span class="built_in">value</span>() - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// respond to keep-alive segment</span></span><br><span class="line">            <span class="built_in">send_</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">send_</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TCPConnection::active</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> active_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPConnection::write</span><span class="params">(<span class="keyword">const</span> string &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> res = sender_.<span class="built_in">stream_in</span>().<span class="built_in">write</span>(data);</span><br><span class="line">    <span class="built_in">send_</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TCPSegment <span class="title">TCPConnection::readSegment_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set Ackno and Window size field of outgoing TCP segments</span></span><br><span class="line">    TCPSegment seg = sender_.<span class="built_in">segments_out</span>().<span class="built_in">front</span>();</span><br><span class="line">    <span class="keyword">if</span> (receiver_.<span class="built_in">ackno</span>().<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        seg.<span class="built_in">header</span>().ack = <span class="literal">true</span>;</span><br><span class="line">        seg.<span class="built_in">header</span>().ackno = receiver_.<span class="built_in">ackno</span>().<span class="built_in">value</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    seg.<span class="built_in">header</span>().win = receiver_.<span class="built_in">window_size</span>();</span><br><span class="line">    sender_.<span class="built_in">segments_out</span>().<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] rst if set, TCPSender must send an empty segment with rst set.</span></span><br><span class="line"><span class="comment">//! \param[in] force if set, TCPSender must at least send one segment.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::send_</span><span class="params">(<span class="keyword">const</span> <span class="keyword">bool</span> rst, <span class="keyword">const</span> <span class="keyword">bool</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rst) &#123;</span><br><span class="line">        TCPSegment seg;</span><br><span class="line">        seg.<span class="built_in">header</span>().rst = <span class="literal">true</span>;</span><br><span class="line">        sender_.<span class="built_in">stream_in</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        receiver_.<span class="built_in">stream_out</span>().<span class="built_in">set_error</span>();</span><br><span class="line">        active_ = <span class="literal">false</span>;</span><br><span class="line">        segments_out_.<span class="built_in">push</span>(seg);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> force_ = force;</span><br><span class="line">    <span class="keyword">if</span> (syn_) &#123;</span><br><span class="line">        <span class="built_in">checkLinger_</span>();</span><br><span class="line">        sender_.<span class="built_in">fill_window</span>();</span><br><span class="line">        <span class="keyword">while</span> (!sender_.<span class="built_in">segments_out</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            force_ = <span class="literal">false</span>;</span><br><span class="line">            TCPSegment seg = <span class="built_in">readSegment_</span>();</span><br><span class="line">            segments_out_.<span class="built_in">push</span>(seg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        force_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (force_) &#123;</span><br><span class="line">        sender_.<span class="built_in">send_empty_segment</span>();</span><br><span class="line">        TCPSegment seg = <span class="built_in">readSegment_</span>();</span><br><span class="line">        segments_out_.<span class="built_in">push</span>(seg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::checkLinger_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inbound_stream</span>().<span class="built_in">input_ended</span>() &amp;&amp; !(sender_.<span class="built_in">stream_in</span>().<span class="built_in">input_ended</span>())) &#123;</span><br><span class="line">        linger_after_streams_finish_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    sender_.<span class="built_in">tick</span>(ms_since_last_tick);</span><br><span class="line">    now_ += ms_since_last_tick;</span><br><span class="line">    <span class="comment">// Abort the connection, and send a reset segment to the peer (an empty segment with the rst flag set)</span></span><br><span class="line">    <span class="comment">// if the number of consecutive retransmissions is more than an upper limit TCPConfig::MAX RETX ATTEMPTS.</span></span><br><span class="line">    <span class="keyword">if</span> (sender_.<span class="built_in">consecutive_retransmissions</span>() &gt; TCPConfig::MAX_RETX_ATTEMPTS)</span><br><span class="line">        <span class="built_in">send_</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">send_</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// end the connection cleanly if necessary</span></span><br><span class="line">    <span class="comment">// If the inbound stream ends before the TCPConnection has reached EOF on its outbound stream, this variable needs</span></span><br><span class="line">    <span class="comment">// to be set to false.</span></span><br><span class="line">    <span class="built_in">checkLinger_</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inbound_stream</span>().<span class="built_in">input_ended</span>() &amp;&amp; sender_.<span class="built_in">stream_in</span>().<span class="built_in">input_ended</span>() &amp;&amp; sender_.<span class="built_in">bytes_in_flight</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (linger_after_streams_finish_) &#123;</span><br><span class="line">            <span class="keyword">if</span> (now_ - last_recv_ &gt;= cfg_.rt_timeout * <span class="number">10</span>) &#123;</span><br><span class="line">                active_ = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            active_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::end_input_stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sender_.<span class="built_in">stream_in</span>().<span class="built_in">end_input</span>();</span><br><span class="line">    <span class="built_in">send_</span>(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPConnection::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    syn_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">send_</span>(<span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TCPConnection::~<span class="built_in">TCPConnection</span>() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">active</span>()) &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;Warning: Unclean shutdown of TCPConnection\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Your code here: need to send a RST segment to the peer</span></span><br><span class="line">            <span class="built_in">send_</span>(<span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> exception &amp;e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception destructing TCP FSM: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4">总结</h3>
<ul>
<li>如何正确的关闭TCP连接？四次挥手后为何还要等待？</li>
<li>RST报文段的作用是什么？需要进行什么操作？</li>
</ul>
<h2 id="测试结果">测试结果</h2>
<p><img src="/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/1.png"></p>
<h2 id="遇到的bug总结遇到的bug和如何解决面试准备">遇到的bug（总结遇到的bug和如何解决，面试准备）</h2>
<ul>
<li><code>checkpoint</code>应该设置为重组的最后一个字节的absolute
seqno</li>
</ul>
<h1 id="网络层链路层">网络层、链路层</h1>
<h2 id="路由器接口">路由器接口</h2>
<h3 id="功能设计-4">功能设计</h3>
<ul>
<li><strong>转发数据报</strong></li>
<li><strong>IP地址</strong>到<strong>链路层地址</strong>的转换，若交换机表中存在则直接索引，若不存在则需通过<strong>ARP查询</strong>获取</li>
</ul>
<h3 id="成员设计-5">成员设计</h3>
<ul>
<li><code>send_datagram(const InternetDatagram&amp;, const Address&amp;)</code>，将该数据报生成以太网帧并发送到目的地址
<ul>
<li>如果该目的地址的链路层<strong>MAC地址已知</strong>，则可以立即<strong>成帧并发送</strong></li>
<li>如果其MAC地址<strong>未知</strong>，则运行<strong>ARP协议</strong>获取</li>
<li>将数据报存储在<strong>输出缓存队列中等待</strong>，直到ARP响应报文到来，获取对应的MAC地址，再从输出队列中取出数据报发送</li>
</ul></li>
<li><code>recv_frame(const EthernetFrame&amp;)</code>，接收以太网的链路层帧，向上传递给对应的网络层协议
<ul>
<li>接收以太网帧，对比MAC地址，如果不是<strong>自己的MAC地址</strong>或<strong>广播地址</strong>，则丢弃该帧</li>
<li>否则，从以太网帧提取数据报
<ul>
<li>如果是<strong>IPv4数据报</strong>，则提取并返回</li>
<li>如果是<strong>ARP响应报文</strong>，则提取并存储该映射关系，同时调用<code>send_datagram</code>发送该地址的缓存队列中的IP数据报</li>
<li>如果是<strong>ARP查询报文</strong>且<strong>目的地址是自己的IP地址</strong>，则返回带映射关系的ARP响应报文</li>
</ul></li>
</ul></li>
<li><code>tick(const size_t)</code>，时间控制
<ul>
<li>控制时间</li>
<li>交换机表中的表项<strong>只能存储30s</strong>，过期即丢弃</li>
<li><strong>5秒内</strong>不要向同一个IP地址发送相同的ARP查询报文</li>
</ul></li>
</ul>
<h3 id="关键问题分析-5">关键问题分析</h3>
<ul>
<li>放在队列中的数据报什么时候传输？
<ul>
<li>当数据报的目的IP地址在交换机表中没有对应表项时，必须<strong>暂存队列</strong>中，等待ARP响应报文获取该地址</li>
<li>当交换机表更新时，即可以超看更新的IP地址是否有需要发送的数据报，有则将队列中的数据报都发送</li>
<li>交换机表更新有两种可能
<ul>
<li><strong>收到ARP响应报文</strong>，对应我们之前发送的某个ARP查询报文</li>
<li><strong>收到其他链路层帧</strong>，提取其MAC地址和IP地址，并把该映射关系放入交换机表（交换机表的自学习特性）</li>
</ul></li>
</ul></li>
<li>数据结构的选用
<ul>
<li>本题涉及<strong>交换机表的存储</strong>，以及<strong>历史ARP查询报文的存储</strong>（防止短时间内对同一IP地址重复查询），都可以用<strong>哈希表</strong>实现，详见“数据结构与算法分析”</li>
</ul></li>
</ul>
<h3 id="数据结构与算法分析-1">数据结构与算法分析</h3>
<ul>
<li><p><strong>交换机表</strong>以何种数据结构存储表项？</p>
<p>交换机表的作用是将<strong>IP地址映</strong>射到<strong>MAC地址</strong>，而且要存储保存的时间，一旦<strong>过期</strong>（实验中设置为30s）则该表项无效，需要（通过<strong>ARP协议</strong>）重新获取，采用<code>unordered_map&lt;uint32_t, pair&lt;EthernetAddress, size_t&gt;&gt;</code>实现</p></li>
<li><p><strong>五秒内</strong>不能向<strong>同一个IP地址重复发送ARP查询报文</strong>，因此需要用<code>unordered_map&lt;uint32_t, size_t&gt;</code>存储各个IP地址及其上一条ARP查询报文的时间，每次发送前先查找，如果上次查询的时间不超过5s则应该继续等待</p></li>
</ul>
<h3 id="类定义-5">类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkInterface</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//! Ethernet (known as hardware, network-access-layer, or link-layer) address of the interface</span></span><br><span class="line">    EthernetAddress _ethernet_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! IP (known as internet-layer or network-layer) address of the interface</span></span><br><span class="line">    Address _ip_address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! outbound queue of Ethernet frames that the NetworkInterface wants sent</span></span><br><span class="line">    std::queue&lt;EthernetFrame&gt; _frames_out&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="keyword">uint32_t</span>, std::pair&lt;EthernetAddress, <span class="keyword">size_t</span>&gt;&gt; f_;</span><br><span class="line">    std::unordered_map&lt;<span class="keyword">uint32_t</span>, <span class="keyword">size_t</span>&gt; request_;</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="keyword">uint32_t</span>, std::queue&lt;InternetDatagram&gt;&gt; q;</span><br><span class="line">    <span class="keyword">size_t</span> curr;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员实现-5">成员实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;network_interface.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;arp_message.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ethernet_frame.hh&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of a network interface</span></span><br><span class="line"><span class="comment">// Translates from &#123;IP datagram, next hop address&#125; to link-layer frame, and from link-layer frame to IP datagram</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 5, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab5`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You will need to add private members to the class declaration in `network_interface.hh`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ethernet_address Ethernet (what ARP calls &quot;hardware&quot;) address of the interface</span></span><br><span class="line"><span class="comment">//! \param[in] ip_address IP (what ARP calls &quot;protocol&quot;) address of the interface</span></span><br><span class="line">NetworkInterface::<span class="built_in">NetworkInterface</span>(<span class="keyword">const</span> EthernetAddress &amp;ethernet_address, <span class="keyword">const</span> Address &amp;ip_address)</span><br><span class="line">    : _ethernet_address(ethernet_address), _ip_address(ip_address), <span class="built_in">f_</span>(&#123;&#125;), <span class="built_in">request_</span>(&#123;&#125;), <span class="built_in">q</span>(&#123;&#125;), <span class="built_in">curr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: Network interface has Ethernet address &quot;</span> &lt;&lt; <span class="built_in">to_string</span>(_ethernet_address) &lt;&lt; <span class="string">&quot; and IP address &quot;</span></span><br><span class="line">         &lt;&lt; ip_address.<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] dgram the IPv4 datagram to be sent</span></span><br><span class="line"><span class="comment">//! \param[in] next_hop the IP address of the interface to send it to (typically a router or default gateway, but may also be another host if directly connected to the same network as the destination)</span></span><br><span class="line"><span class="comment">//! (Note: the Address type can be converted to a uint32_t (raw 32-bit IP address) with the Address::ipv4_numeric() method.)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::send_datagram</span><span class="params">(<span class="keyword">const</span> InternetDatagram &amp;dgram, <span class="keyword">const</span> Address &amp;next_hop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// convert IP address of next hop to raw 32-bit representation (used in ARP header)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> next_hop_ip = next_hop.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    <span class="keyword">if</span> (f_.<span class="built_in">count</span>(next_hop_ip)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f_[next_hop_ip].second + <span class="number">30000</span> &lt; curr)</span><br><span class="line">            f_.<span class="built_in">erase</span>(next_hop_ip);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            EthernetFrame frame;</span><br><span class="line">            frame.<span class="built_in">payload</span>() = dgram.<span class="built_in">serialize</span>();</span><br><span class="line">            frame.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">            frame.<span class="built_in">header</span>().dst = f_[next_hop_ip].first;</span><br><span class="line">            frame.<span class="built_in">header</span>().type = EthernetHeader::TYPE_IPv4;</span><br><span class="line">            _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    q[next_hop_ip].<span class="built_in">push</span>(dgram);</span><br><span class="line">    <span class="keyword">if</span> (request_.<span class="built_in">count</span>(next_hop_ip) &amp;&amp; request_[next_hop_ip] + <span class="number">5000</span> &gt;= curr)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    EthernetFrame frame;</span><br><span class="line">    ARPMessage msg;</span><br><span class="line">    msg.opcode = ARPMessage::OPCODE_REQUEST;</span><br><span class="line">    msg.sender_ethernet_address = _ethernet_address;</span><br><span class="line">    msg.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">    msg.target_ip_address = next_hop_ip;</span><br><span class="line">    frame.<span class="built_in">payload</span>() = msg.<span class="built_in">serialize</span>();</span><br><span class="line">    frame.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">    frame.<span class="built_in">header</span>().dst = ETHERNET_BROADCAST;</span><br><span class="line">    frame.<span class="built_in">header</span>().type = EthernetHeader::TYPE_ARP;</span><br><span class="line">    _frames_out.<span class="built_in">push</span>(frame);</span><br><span class="line">    request_[next_hop_ip] = curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] frame the incoming Ethernet frame</span></span><br><span class="line"><span class="function">optional&lt;InternetDatagram&gt; <span class="title">NetworkInterface::recv_frame</span><span class="params">(<span class="keyword">const</span> EthernetFrame &amp;frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (frame.<span class="built_in">header</span>().dst == ETHERNET_BROADCAST || frame.<span class="built_in">header</span>().dst == _ethernet_address) &#123;</span><br><span class="line">        <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_ARP) &#123;</span><br><span class="line">            ARPMessage msg;</span><br><span class="line">            <span class="keyword">if</span> (!(msg.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>()) == ParseResult::NoError))</span><br><span class="line">                <span class="keyword">return</span> nullopt;</span><br><span class="line">            <span class="keyword">if</span> (msg.target_ip_address != _ip_address.<span class="built_in">ipv4_numeric</span>())</span><br><span class="line">                <span class="keyword">return</span> nullopt;</span><br><span class="line">            f_[msg.sender_ip_address] = std::<span class="built_in">make_pair</span>(msg.sender_ethernet_address, curr);</span><br><span class="line">            <span class="comment">// send an ARP reply Message</span></span><br><span class="line">            <span class="keyword">if</span> (msg.opcode == ARPMessage::OPCODE_REQUEST) &#123;</span><br><span class="line">                EthernetFrame reply_frame;</span><br><span class="line">                ARPMessage reply;</span><br><span class="line">                reply.opcode = ARPMessage::OPCODE_REPLY;</span><br><span class="line">                reply.sender_ethernet_address = _ethernet_address;</span><br><span class="line">                reply.sender_ip_address = _ip_address.<span class="built_in">ipv4_numeric</span>();</span><br><span class="line">                reply.target_ethernet_address = msg.sender_ethernet_address;</span><br><span class="line">                reply.target_ip_address = msg.sender_ip_address;</span><br><span class="line">                reply_frame.<span class="built_in">payload</span>() = reply.<span class="built_in">serialize</span>();</span><br><span class="line">                reply_frame.<span class="built_in">header</span>().src = _ethernet_address;</span><br><span class="line">                reply_frame.<span class="built_in">header</span>().dst = msg.sender_ethernet_address;</span><br><span class="line">                reply_frame.<span class="built_in">header</span>().type = EthernetHeader::TYPE_ARP;</span><br><span class="line">                _frames_out.<span class="built_in">push</span>(reply_frame);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// send datagram in the output buffer if possible</span></span><br><span class="line">            Address addr = Address::<span class="built_in">from_ipv4_numeric</span>(msg.sender_ip_address);</span><br><span class="line">            <span class="keyword">while</span> (!q[msg.sender_ip_address].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="built_in">send_datagram</span>(q[msg.sender_ip_address].<span class="built_in">front</span>(), addr);</span><br><span class="line">                q[msg.sender_ip_address].<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (frame.<span class="built_in">header</span>().type == EthernetHeader::TYPE_IPv4) &#123;</span><br><span class="line">            InternetDatagram dgram;</span><br><span class="line">            <span class="keyword">if</span> (dgram.<span class="built_in">parse</span>(frame.<span class="built_in">payload</span>()) == ParseResult::NoError)</span><br><span class="line">                <span class="keyword">return</span> dgram;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> nullopt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nullopt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkInterface::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123; </span><br><span class="line">    curr += ms_since_last_tick; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-5">总结</h3>
<ul>
<li>本实验重点是对<strong>网络层数据平面、链路层</strong>的实现，重点在于对IP地址、链路层帧、链路层帧表头、IP数据报、ARP报文等类的<strong>接口的正确使用</strong></li>
<li>实现了<strong>交换机表</strong>的<strong>自学习、过期</strong>等机制</li>
<li>实现了<strong>ARP协议</strong>中发送ARP查询报文、回复ARP响应报文等机制，当发送ARP查询报文时使用的是<strong>MAC广播地址</strong><code>FF-FF-FF-FF-FF-FF</code></li>
<li>协议层次特点及其带来好处，本实验同时涉及了<strong>网络层、链路层中的操作</strong>，由于网络层数据报完全作为链路层帧的数据发送，因此<strong>从链路层帧提取数据报</strong>，以及<strong>将数据报封装成链路层帧</strong>的操作都非常方便，通过<code>parse</code>、<code>serialize</code>等成员即可完成</li>
</ul>
<h1 id="网络层-控制平面">网络层-控制平面</h1>
<h2 id="路由器">路由器</h2>
<h3 id="功能设计-5">功能设计</h3>
<ul>
<li>维护路由器的<strong>转发表</strong></li>
<li>当数据报到来时，进行<strong>基于目的地转发</strong></li>
<li>维护<strong>数据报的TTL值</strong>并据此判断其是否应该被丢弃</li>
</ul>
<h3 id="成员设计-6">成员设计</h3>
<ul>
<li><code>add_route(route_prefix, prefix_length, next_hop, interface_num)</code>，<strong>新增一个转发表项</strong>，IP地址前缀为<code>route_prefix</code>，前缀长度为<code>prefix_length</code>，通往该地址的路径上下一个路由器的地址是<code>next_hop</code>，对应的路由器输出端口编号是<code>interface_num</code></li>
<li><code>route_one_datagram(InternetDatagram&amp;)</code>，将一个<strong>数据报</strong>进行<strong>转发</strong>
<ul>
<li>若找到了<strong>匹配的表项</strong>，则从中选择前缀长度最长的一个（<strong>最长前缀匹配规则</strong>），并根据该表项的<code>next_hop</code>和<code>interface</code>信息进行转发</li>
<li>若<strong>没有</strong>找到对应的表项，则忽略该数据报</li>
</ul></li>
</ul>
<h3 id="关键问题分析-6">关键问题分析</h3>
<ul>
<li>进行前缀匹配时，假如该表项的地址为<code>addr1</code>，目的地址为<code>addr2</code>，而该表项的<strong>前缀长度</strong>为<code>len</code>，则<strong><code>add1</code>和<code>add2</code>的前<code>len</code>都一致时，才认为它们匹配</strong></li>
<li><strong>转发表</strong>应该使用什么数据结构实现？
<ul>
<li>如果直接用<strong>数组存储</strong>，则对于每次查找，都要将目的地址与每个表项进行对比，才能完成最长前缀匹配，因此时间复杂度是<span class="math inline">\(O(N)\)</span>的，其中<span class="math inline">\(N\)</span>为查找时转发表的表项数量</li>
<li>借助<strong>前缀树Trie</strong>，可以使每次查找的时间降为<span class="math inline">\(O(logN)\)</span></li>
</ul></li>
</ul>
<h3 id="数据结构与算法分析-2">数据结构与算法分析</h3>
<ul>
<li><strong>前缀树</strong>实现<span class="math inline">\(O(logN)\)</span>的最长前缀匹配规则</li>
</ul>
<h3 id="类定义-6">类定义</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> interface_num;</span><br><span class="line">    std::optional&lt;Address&gt; next_hop&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;Trie&gt; left&#123;&#125;;</span><br><span class="line">    std::shared_ptr&lt;Trie&gt; right&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>(<span class="keyword">int</span> i = <span class="number">0</span>, std::optional&lt;Address&gt; hop=std::nullopt): <span class="built_in">interface_num</span>(i), <span class="built_in">next_hop</span>(hop) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createLeftChild</span><span class="params">(<span class="keyword">int</span> i = <span class="number">-1</span>, std::optional&lt;Address&gt; hop = std::nullopt)</span> </span>&#123;</span><br><span class="line">        left = std::make_shared&lt;Trie&gt;(i, hop);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createRightChild</span><span class="params">(<span class="keyword">int</span> i = <span class="number">-1</span>, std::optional&lt;Address&gt; hop = std::nullopt)</span> </span>&#123;</span><br><span class="line">        right = std::make_shared&lt;Trie&gt;(i, hop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> &#123;</span></span><br><span class="line">    <span class="comment">//! The router&#x27;s collection of network interfaces</span></span><br><span class="line">    std::vector&lt;AsyncNetworkInterface&gt; _interfaces&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Send a single datagram from the appropriate outbound interface to the next hop,</span></span><br><span class="line">    <span class="comment">//! as specified by the route with the longest prefix_length that matches the</span></span><br><span class="line">    <span class="comment">//! datagram&#x27;s destination address.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span></span>;</span><br><span class="line">    std::shared_ptr&lt;Trie&gt; route_table&#123;std::make_shared&lt;Trie&gt;(<span class="number">-1</span>)&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="成员实现-6">成员实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;router.hh&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy implementation of an IP router</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Given an incoming Internet datagram, the router decides</span></span><br><span class="line"><span class="comment">// (1) which interface to send it out on, and</span></span><br><span class="line"><span class="comment">// (2) what next hop address to send it to.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// For Lab 6, please replace with a real implementation that passes the</span></span><br><span class="line"><span class="comment">// automated checks run by `make check_lab6`.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You will need to add private members to the class declaration in `router.hh`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Targs&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DUMMY_CODE</span><span class="params">(Targs &amp;&amp;... <span class="comment">/* unused */</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] route_prefix The &quot;up-to-32-bit&quot; IPv4 address prefix to match the datagram&#x27;s destination address against</span></span><br><span class="line"><span class="comment">//! \param[in] prefix_length For this route to be applicable, how many high-order (most-significant) bits of the route_prefix will need to match the corresponding bits of the datagram&#x27;s destination address?</span></span><br><span class="line"><span class="comment">//! \param[in] next_hop The IP address of the next hop. Will be empty if the network is directly attached to the router (in which case, the next hop address should be the datagram&#x27;s final destination).</span></span><br><span class="line"><span class="comment">//! \param[in] interface_num The index of the interface to send the datagram out on.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Router::add_route</span><span class="params">(<span class="keyword">const</span> <span class="keyword">uint32_t</span> route_prefix,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">uint8_t</span> prefix_length,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> optional&lt;Address&gt; next_hop,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="keyword">const</span> <span class="keyword">size_t</span> interface_num)</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;DEBUG: adding route &quot;</span> &lt;&lt; Address::<span class="built_in">from_ipv4_numeric</span>(route_prefix).<span class="built_in">ip</span>() &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">int</span></span>(prefix_length)</span><br><span class="line">         &lt;&lt; <span class="string">&quot; =&gt; &quot;</span> &lt;&lt; (next_hop.<span class="built_in">has_value</span>() ? next_hop-&gt;<span class="built_in">ip</span>() : <span class="string">&quot;(direct)&quot;</span>) &lt;&lt; <span class="string">&quot; on interface &quot;</span> &lt;&lt; interface_num &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="comment">// route_table[route_prefix] = make_tuple(prefix_length, next_hop, interface_num);</span></span><br><span class="line">    <span class="keyword">auto</span> curr = route_table;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; prefix_length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (route_prefix &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!curr-&gt;right) </span><br><span class="line">                curr-&gt;<span class="built_in">createRightChild</span>();</span><br><span class="line">            curr = curr-&gt;right;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!curr-&gt;left)</span><br><span class="line">                curr-&gt;<span class="built_in">createLeftChild</span>();</span><br><span class="line">            curr = curr-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    curr-&gt;next_hop = next_hop;</span><br><span class="line">    curr-&gt;interface_num = interface_num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] dgram The datagram to be routed</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Router::route_one_datagram</span><span class="params">(InternetDatagram &amp;dgram)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line">    <span class="keyword">if</span> (dgram.<span class="built_in">header</span>().ttl &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// Trie</span></span><br><span class="line">    <span class="keyword">uint32_t</span> addr = dgram.<span class="built_in">header</span>().dst;</span><br><span class="line">    <span class="keyword">auto</span> curr = route_table;</span><br><span class="line">    <span class="keyword">int</span> interface = <span class="number">-1</span>;</span><br><span class="line">    optional&lt;Address&gt; hop = nullopt;</span><br><span class="line">    <span class="keyword">if</span> (curr-&gt;interface_num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        interface = curr-&gt;interface_num;</span><br><span class="line">        hop = curr-&gt;next_hop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addr &amp; (<span class="number">1</span> &lt;&lt; (<span class="number">31</span> - i))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;right)</span><br><span class="line">                curr = curr-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr-&gt;left)</span><br><span class="line">                curr = curr-&gt;left;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (curr-&gt;interface_num &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            interface = curr-&gt;interface_num;</span><br><span class="line">            hop = curr-&gt;next_hop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (interface == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    --dgram.<span class="built_in">header</span>().ttl;</span><br><span class="line">    Address ad = hop.<span class="built_in">has_value</span>()? hop.<span class="built_in">value</span>(): Address::<span class="built_in">from_ipv4_numeric</span>(addr);</span><br><span class="line">    _interfaces[interface].<span class="built_in">send_datagram</span>(dgram, ad);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* brute force matching</span></span><br><span class="line"><span class="comment">    uint32_t addr = dgram.header().dst;</span></span><br><span class="line"><span class="comment">    size_t maxlen = 0;</span></span><br><span class="line"><span class="comment">    uint32_t prefix = 0;</span></span><br><span class="line"><span class="comment">    for (auto&amp; it: route_table) &#123;</span></span><br><span class="line"><span class="comment">        bool flag = true;</span></span><br><span class="line"><span class="comment">        for (size_t i = 0; i &lt; std::get&lt;0&gt;(it.second); ++i) &#123;</span></span><br><span class="line"><span class="comment">            if ((addr &amp; (1 &lt;&lt; (31 - i))) != (it.first &amp; (1 &lt;&lt; (31 - i)))) &#123;</span></span><br><span class="line"><span class="comment">                flag = false;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (flag &amp;&amp; std::get&lt;0&gt;(it.second) &gt; maxlen) &#123;</span></span><br><span class="line"><span class="comment">            maxlen = std::get&lt;0&gt;(it.second);</span></span><br><span class="line"><span class="comment">            prefix = it.first;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    Address ad = std::get&lt;1&gt;(route_table[prefix]).has_value()? std::get&lt;1&gt;(route_table[prefix]).value(): Address::from_ipv4_numeric(addr);</span></span><br><span class="line"><span class="comment">    --dgram.header().ttl;</span></span><br><span class="line"><span class="comment">    _interfaces[std::get&lt;2&gt;(route_table[prefix])].send_datagram(dgram, ad);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Router::route</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Go through all the interfaces, and route every incoming datagram to its proper outgoing interface.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;interface : _interfaces) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;queue = interface.<span class="built_in">datagrams_out</span>();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">not</span> queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="built_in">route_one_datagram</span>(queue.<span class="built_in">front</span>());</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-6">总结</h3>
<ul>
<li>通过<strong>前缀树</strong>代替数组存储转发表，<strong>优化了</strong>最长前缀匹配的时间复杂度，从<span class="math inline">\(O(N)\)</span>将为<span class="math inline">\(O(logN)\)</span></li>
<li>实现前缀树时，由于需要<strong>动态分配内存</strong>，因此采用<strong>智能指针</strong><code>shared_ptr</code>管理每个树节点的分配</li>
<li>查找前缀树时，受一般前缀树的思路影响，导致了bug，具体来说
<ul>
<li>以字典树为例，字典树将<strong>单词存储</strong>起来，<strong>给定</strong>一个<strong>前缀</strong>，看词典中是否有匹配的单词</li>
<li>这里我们的前缀树<strong>存储</strong>转发表中的网址<strong>前缀</strong>，<strong>给定</strong>一个<strong>目的地址</strong>，查找最长匹配前缀。因此查找时，必须到达前缀的末尾才认为匹配成功</li>
<li>我们通过节点的<code>next_hop</code>和<code>interface_num</code>值辨别是否到达了前缀的结尾，如果一个节点并非对应前缀结尾，则其<code>interface_num</code>的值为-1</li>
<li>查找过程中，我们不断更新<code>hop</code>和<code>interface</code>，分别代表当前最长匹配前缀对应节点的<code>next_hop</code>和<code>interface_num</code>，最终查找结束我们就得知，应该<strong>将数据报转发到编号为<code>interface</code>的输出端口</strong>，且下一台<strong>路由器的地址为<code>next_hop</code></strong></li>
</ul></li>
</ul>
<h1 id="cs-144-lab最终测试结果">CS-144 lab最终测试结果</h1>
<ul>
<li>至此，CS-144实验的各个模块已完成，测试结果如下！成功撒花！</li>
</ul>
<p><img src="/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/2.png"></p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Young
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/03/01/%E9%A1%B9%E7%9B%AE-%E5%AE%9E%E7%8E%B0TCP%E8%BF%9E%E6%8E%A5/" title="项目-实现TCP连接">http://example.com/2022/03/01/项目-实现TCP连接/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E9%A1%B9%E7%9B%AE/" rel="tag"># 项目</a>
              <a href="/tags/Computer-Network/" rel="tag"># Computer Network</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/28/%E8%AE%A1%E7%BD%91-%E9%93%BE%E8%B7%AF%E5%B1%82/" rel="prev" title="计网-链路层">
                  <i class="fa fa-chevron-left"></i> 计网-链路层
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/03/02/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" rel="next" title="算法-排序">
                  算法-排序 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Young</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
