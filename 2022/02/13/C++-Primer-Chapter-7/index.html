<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.8.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="第七章 类 7.1 定义抽象数据类型 实现Sales_data类 接口  isbn成员函数，用于返回对象的ISBN编号 combine成员函数，用于将一个Sales_data对象加到另一个对象上 add函数，执行两个Sales_data对象的加法 read函数，从istream中读取数据到Sales_data对象中 print函数，将Sales_data对象的值输出到ostream  定义成员函数">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer Chapter 7">
<meta property="og:url" content="http://example.com/2022/02/13/C++-Primer-Chapter-7/index.html">
<meta property="og:site_name" content="元朗食品">
<meta property="og:description" content="第七章 类 7.1 定义抽象数据类型 实现Sales_data类 接口  isbn成员函数，用于返回对象的ISBN编号 combine成员函数，用于将一个Sales_data对象加到另一个对象上 add函数，执行两个Sales_data对象的加法 read函数，从istream中读取数据到Sales_data对象中 print函数，将Sales_data对象的值输出到ostream  定义成员函数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-13T14:11:23.000Z">
<meta property="article:modified_time" content="2022-04-08T12:08:32.852Z">
<meta property="article:author" content="Young">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/02/13/C++-Primer-Chapter-7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/02/13/C++-Primer-Chapter-7/","path":"2022/02/13/C++-Primer-Chapter-7/","title":"C++ Primer Chapter 7"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ Primer Chapter 7 | 元朗食品</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">元朗食品</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB"><span class="nav-text">第七章 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.1 定义抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0sales_data%E7%B1%BB"><span class="nav-text">实现Sales_data类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">定义成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%86%85%E9%83%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E6%98%AFinline%E7%9A%84"><span class="nav-text">定义在类内部的成员函数默认是inline的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#isbn%E5%87%BD%E6%95%B0"><span class="nav-text">isbn函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this"><span class="nav-text">this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">const成员函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">类作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E5%AE%9A%E4%B9%89%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">在类外部定义的成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#avg_price%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">avg_price成员函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E8%BF%94%E5%9B%9Ethis%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%BD%E6%95%B0"><span class="nav-text">定义一个返回this对象的函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#combine%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">combine成员函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">定义类相关的非成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89read%E5%87%BD%E6%95%B0%E5%92%8Cprint%E5%87%BD%E6%95%B0"><span class="nav-text">定义read函数和print函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89add%E5%87%BD%E6%95%B0"><span class="nav-text">定义add函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%90%88%E6%88%90%E7%9A%84%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">不能依赖于合成的默认构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%99sales_data%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">给Sales_data定义构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#default%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-text">&#x3D;default的含义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="nav-text">构造函数初始值列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%AE%9A%E4%B9%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">在类外定义构造函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC%E6%9E%90%E6%9E%84"><span class="nav-text">拷贝、赋值、析构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%90%E4%BA%9B%E7%B1%BB%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E4%BA%8E%E5%90%88%E6%88%90%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-text">某些类不能依赖于合成的版本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="nav-text">7.2 访问控制与封装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%81%E8%A3%85%E5%B0%81%E8%A3%85%E6%9C%89%E4%BD%95%E4%BC%98%E7%82%B9"><span class="nav-text">什么是封装？封装有何优点？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E8%AF%B4%E6%98%8E%E7%AC%A6"><span class="nav-text">访问说明符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class%E5%92%8Cstruct%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">class和struct的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%8A%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="nav-text">把函数作为友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">友元声明的位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E"><span class="nav-text">友元声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-text">7.3 类和其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98"><span class="nav-text">定义类型成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E4%BD%9C%E4%B8%BA%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">令成员作为内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">重载成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">可变数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="nav-text">类数据成员的初始值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9Ethis%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">返回*this的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-text">类类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">类的声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="nav-text">不完全类型可使用的场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E7%B1%BB%E5%9E%8B%E4%B8%8D%E8%83%BD%E6%98%AF%E8%AF%A5%E7%B1%BB%E8%87%AA%E5%B7%B1"><span class="nav-text">类的成员类型不能是该类自己</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83-1"><span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8F%8B%E5%85%83%E5%85%B3%E7%B3%BB"><span class="nav-text">类之间的友元关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83"><span class="nav-text">令成员函数作为友元</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BB%A4%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%8B%E5%85%83%E7%9A%84%E5%AE%9A%E4%B9%89%E6%AD%A5%E9%AA%A4"><span class="nav-text">令成员函数作为友元的定义步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E4%B8%8E%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-text">友元与重载函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">友元声明与作用域</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%9C%A8%E4%BA%8E%E5%8F%8B%E5%85%83%E5%A3%B0%E6%98%8E%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%AA%E6%94%B9%E5%8F%98%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E5%AE%83%E6%97%A0%E6%B3%95%E5%8F%96%E4%BB%A3%E6%99%AE%E9%80%9A%E6%84%8F%E4%B9%89%E4%B8%8A%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="nav-text">关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">7.4 类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%AE%9A%E4%B9%89%E5%9C%A8%E7%B1%BB%E5%A4%96%E9%83%A8%E7%9A%84%E6%88%90%E5%91%98"><span class="nav-text">作用域和定义在类外部的成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">名字查找与类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%88%86%E4%B8%A4%E6%AD%A5%E5%A4%84%E7%90%86"><span class="nav-text">类的定义分两步处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%90%8D%E7%9A%84%E7%89%B9%E6%AE%8A%E4%B9%8B%E5%A4%84"><span class="nav-text">类型名的特殊之处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%AE%9A%E4%B9%89%E4%B8%AD%E7%9A%84%E6%99%AE%E9%80%9A%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE"><span class="nav-text">成员定义中的普通块作用域的名字查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%B7%B1%E5%85%A5"><span class="nav-text">7.5 构造函数深入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">初始化与赋值的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="nav-text">成员初始化的顺序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%BB%98%E8%AE%A4%E5%AE%9E%E5%8F%82"><span class="nav-text">构造函数的默认实参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">委托构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">默认构造函数的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">隐式的类类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%81%9A%E7%9A%84%E4%BA%8B"><span class="nav-text">编译器做的事</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E6%AD%A5%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">只允许一步类类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%B9%B6%E9%9D%9E%E6%80%BB%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84"><span class="nav-text">类类型转换并非总是有效的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%91%E5%88%B6%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">抑制隐式的类类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E7%94%A8%E4%BA%8E%E7%9B%B4%E6%8E%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8D%E8%83%BD%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">explicit构造函数只能用于直接初始化，不能拷贝初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#static_cast%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">static_cast可以使用explicit构造函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E4%B8%AD%E5%90%AB%E6%9C%89explicit%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB"><span class="nav-text">标准库中含有explicit构造函数的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-text">聚合类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BBskip"><span class="nav-text">字面值常量类（skip）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">7.6 类的静态成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">声明静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">使用静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">定义静态成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">静态成员的类内初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">静态成员和普通成员的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-text">习题</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Young"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Young</p>
  <div class="site-description" itemprop="description">Talk is cheap, show me the code.</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">117</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>


<!-- require APlayer -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css">

<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script>
<!-- require MetingJS-->

<script src="https://cdn.jsdelivr.net/npm/meting@2.0.1/dist/Meting.min.js"></script> 
<!--playlist外链地址-->   
<meting-js
  server="tencent"
  type="playlist" 
  id="8356942170"
  mini="false"
  fixed="false"
  list-folded="true"
  autoplay="false"
  volume="0.4"
  theme="#FADFA3"
  order="list"
  loop="all"
  preload="auto"
  lrc-type="1"
  mutex="true">
</meting-js>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/02/13/C++-Primer-Chapter-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Young">
      <meta itemprop="description" content="Talk is cheap, show me the code.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="元朗食品">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ Primer Chapter 7
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-13 22:11:23" itemprop="dateCreated datePublished" datetime="2022-02-13T22:11:23+08:00">2022-02-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-04-08 20:08:32" itemprop="dateModified" datetime="2022-04-08T20:08:32+08:00">2022-04-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="第七章-类">第七章 类</h1>
<h2 id="定义抽象数据类型">7.1 定义抽象数据类型</h2>
<h3 id="实现sales_data类">实现Sales_data类</h3>
<h4 id="接口">接口</h4>
<ul>
<li><code>isbn</code>成员函数，用于返回对象的ISBN编号</li>
<li><code>combine</code>成员函数，用于将一个Sales_data对象加到另一个对象上</li>
<li><code>add</code>函数，执行两个Sales_data对象的加法</li>
<li><code>read</code>函数，从<code>istream</code>中读取数据到Sales_data对象中</li>
<li><code>print</code>函数，将Sales_data对象的值输出到<code>ostream</code></li>
</ul>
<h4 id="定义成员函数">定义成员函数</h4>
<ul>
<li><strong>成员函数的声明必须在类的内部，定义则既可在类的内部，也可在类的外部</strong></li>
</ul>
<h5 id="定义在类内部的成员函数默认是inline的">定义在类内部的成员函数默认是inline的</h5>
<h5 id="isbn函数"><code>isbn</code>函数</h5>
<ul>
<li>返回<code>Sales_data</code>的书本编号</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookno; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="this">this</h4>
<ul>
<li>成员函数通过<strong>一个名为<code>this</code>的额外的隐式参数访问调用它的那个对象</strong>，当我们调用成员函数时，用请求该函数的对象的地址初始化<code>this</code></li>
<li>在成员函数内部，我们可以直接使用调用该函数的对象的成员。<strong>任何对类成员的直接访问，都被看做this的隐式引用</strong>，所以当<code>isbn</code>使用<code>bookno</code>时，就像我们使用了<code>this-&gt;bookno</code>一样</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookno; &#125;</span><br><span class="line"><span class="comment">// 尽管没必要, 但isbn可如上定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>this</code>是一个<strong>常量指针</strong>，不允许改变<code>this</code>的地址，任何自定义名为<code>this</code>的参数或变量的行为都是非法的</li>
</ul>
<h4 id="const成员函数">const成员函数</h4>
<ul>
<li><code>isbn</code>函数形参列表后紧跟着<code>const</code>，这里<strong>const的作用是修改隐式<code>this</code>指针的类型</strong></li>
<li>形参列表的const表明<code>this</code>是一个指向常量的指针，因此<code>this</code>是<strong>一个指向常量的常量指针</strong></li>
<li>使用const的成员函数称为<strong>常量成员函数</strong></li>
</ul>
<h4 id="类作用域">类作用域</h4>
<ul>
<li>类本身是一个作用域</li>
<li>编译器分两步处理类，先编译成员的声明，再处理成员函数体。因此<strong>成员函数体可随意使用类中的其他成员</strong>，无需在意声明次序</li>
</ul>
<h4 id="在类外部定义的成员函数">在类外部定义的成员函数</h4>
<ul>
<li>成员函数必须在类内声明，但允许在类外进行定义</li>
<li>类外部定义的成员函数必须<strong>包含它所属的类名</strong></li>
</ul>
<h5 id="avg_price成员函数"><code>avg_price</code>成员函数</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (units_sold == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="定义一个返回this对象的函数">定义一个返回this对象的函数</h4>
<h5 id="combine成员函数"><code>combine</code>成员函数</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; rhs)</span> </span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>combine</code>应该返回指向调用该函数的对象的引用，而<code>this</code>存放了该对象的地址，因此对其解引用即可得到指向该对象的引用</li>
</ul>
<h4 id="定义类相关的非成员函数">定义类相关的非成员函数</h4>
<ul>
<li>如果函数在概念上属于类，但不是类的成员函数，那么<strong>一般也和类在同一个头文件中声明</strong>，这样用户使用类接口的任何部分都只需引入一个头文件</li>
</ul>
<h5 id="定义read函数和print函数">定义<code>read</code>函数和<code>print</code>函数</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp; os, <span class="keyword">const</span> Sales_data&amp; item)</span> </span>&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp; is, Sales_data&amp; item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookno &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>read</code>和<code>print</code>接收的都是IO类型的引用，这是因为IO类不能被拷贝，只能通过引用传递</li>
<li>此外，输入输出会改变流的内容，因此无法声明为对常量的引用，只能是普通引用</li>
</ul>
<h5 id="定义add函数">定义<code>add</code>函数</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; item1, <span class="keyword">const</span> Sales_data&amp; item2)</span> </span>&#123;</span><br><span class="line">    Sales_data item = item1;</span><br><span class="line">    item.<span class="built_in">combine</span>(item2);</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构造函数">构造函数</h3>
<ul>
<li><p>类定义了其对象被初始化的方式，通过一个或几个特殊的成员函数控制其对象初始化的过程，这些函数称为<strong>构造函数</strong></p></li>
<li><p>构造函数用于<strong>初始化类对象的数据成员</strong>，只要类的对象被创建，就会执行构造函数</p></li>
<li><p>构造函数的基本特点</p>
<ul>
<li><p>构造函数<strong>没有返回类型</strong></p></li>
<li><p>函数名<strong>与类名相同</strong></p></li>
<li><p><strong>可以有多个构造函数</strong>，与其他重载函数类似</p></li>
<li><p>构造函数<strong>不能声明为const</strong>，即使是const对象在初始化过程也可以向其写值</p></li>
</ul></li>
</ul>
<h4 id="合成的默认构造函数">合成的默认构造函数</h4>
<ul>
<li>如果类<strong>没有显式地定义任何构造函数</strong>，则<strong>编译器会隐式地定义一个默认构造函数，称为合成的默认构造函数</strong></li>
<li>默认构造函数的行为
<ul>
<li>如果没有<strong>类内初始值</strong>，就执行<strong>默认初始化</strong></li>
</ul></li>
</ul>
<h4 id="不能依赖于合成的默认构造函数">不能依赖于合成的默认构造函数</h4>
<ul>
<li><p>只有类没有定义任何构造函数时，编译器才会隐式地定义合成的默认构造函数</p></li>
<li><p>对于<strong>内置类型或复合类型</strong>，若没有提供类内初始值，将执行<strong>默认初始化</strong>，<strong>其值是未定义的</strong></p></li>
<li><p>有时候编译器不能为某些类合成默认的构造函数</p></li>
<li><p>因此，定义了其他构造函数后，应该<strong>自定义一个默认构造函数（形参列表为空）</strong></p></li>
</ul>
<h4 id="给sales_data定义构造函数">给<code>Sales_data</code>定义构造函数</h4>
<ul>
<li><p>默认构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="default的含义"><code>=default</code>的含义</h5>
<ul>
<li>C++11规定如果需要默认行为，可以通过在参数列表后写上<code>=default</code>来要求编译器生成构造函数</li>
<li><code>=default</code>既可以与声明一起出现在类的内部，也可以作为定义出现在类的外部</li>
<li>这时候，编译器生成构造函数会执行默认初始化，因此<strong>只有保证数据成员的值不会是未定义时，才使用<code>=default</code></strong></li>
</ul>
<h5 id="构造函数初始值列表">构造函数初始值列表</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string&amp; b, <span class="keyword">unsigned</span> u, <span class="keyword">double</span> p): <span class="built_in">bookno</span>(b), <span class="built_in">units_sold</span>(u), <span class="built_in">revenue</span>(p*u) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="keyword">const</span> std::string&amp; b): <span class="built_in">bookno</span>(b) &#123;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>构造函数初始值列表，用于为新创建对象的一个或几个数据成员赋初值</p></li>
<li><p>数据成员<strong>名字后面紧跟括号括起来的成员初始值</strong>，不同成员的初始化通过<strong>逗号隔开</strong></p></li>
<li><p>若某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式进行初始化，及若有类内初始值则初始化为该值，否则默认初始化。因此没有提供类内初始值的内置类型，不应被构造函数初始值列表忽略</p></li>
</ul>
<h5 id="在类外定义构造函数">在类外定义构造函数</h5>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::<span class="built_in">Sales_data</span>(std::istream&amp; is) &#123;</span><br><span class="line">    <span class="built_in">read</span>(is, *<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拷贝赋值析构">拷贝、赋值、析构</h3>
<ul>
<li>类还需要控制拷贝、赋值和销毁对象时发生的行为</li>
<li>若不主动定义，则编译器将替我们合成。</li>
</ul>
<h4 id="某些类不能依赖于合成的版本">某些类不能依赖于合成的版本</h4>
<ul>
<li>某些类中合成的版本无法正常工作，特别是<strong>类需要分配对象之外的资源时</strong></li>
</ul>
<h2 id="访问控制与封装">7.2 访问控制与封装</h2>
<h3 id="什么是封装封装有何优点">什么是封装？封装有何优点？</h3>
<ul>
<li>实现了类的接口与实现的分离，类对外隐藏了其实现细节，类的用户只需使用接口即可，无法访问实现部分</li>
<li>封装的优点是
<ul>
<li>确保用户代码<strong>不会无意间破坏封装对象的状态</strong></li>
<li>被封装的类的具体实现细节可随时改变，而<strong>无需调整用户级别的代码</strong></li>
</ul></li>
</ul>
<h3 id="访问说明符">访问说明符</h3>
<ul>
<li><p>C++通过<strong>访问说明符</strong>加强类的封装性</p></li>
<li><p><strong>public说明符</strong>后的成员在整个成员内可以被访问</p></li>
<li><p><strong>private说明符</strong>后的成员只能被类的成员函数访问</p></li>
<li><p>一个类可以包含0或多个访问说明符，每个访问说明符的出现次数也没有限制</p></li>
</ul>
<h3 id="class和struct的区别">class和struct的区别</h3>
<ul>
<li>class和struct都可用于定义类</li>
<li>唯一区别是默认访问权限
<ul>
<li>struct在第一个访问说明符前的成员是public的</li>
<li>class在第一个访问说明符前的成员是private的</li>
</ul></li>
</ul>
<h3 id="友元">友元</h3>
<ul>
<li>想让其他类或非成员函数访问类的非公有成员，则可以<strong>让其他类或函数成为自己的友元（friend）</strong></li>
</ul>
<h4 id="把函数作为友元">把函数作为友元</h4>
<ul>
<li>在类定义中<strong>增加一条以<code>friend</code>关键字开头的函数声明</strong></li>
</ul>
<h4 id="友元声明的位置">友元声明的位置</h4>
<ul>
<li>友元声明必须在类定义内部，但在哪个位置不限，它不是类成员，不受访问说明符的约束</li>
<li>但最好把友元声明<strong>集中在类定义的开始，或类定义的结束位置</strong></li>
</ul>
<h4 id="友元声明">友元声明</h4>
<ul>
<li>友元声明并非通常意义上的函数声明，因此除了在类内部进行友元声明，<strong>使用该函数前还需要有该函数本身的声明</strong></li>
<li>一般将该函数本身的声明与类定义放在同一个头文件中</li>
</ul>
<h2 id="类和其他特性">7.3 类和其他特性</h2>
<h3 id="定义类型成员">定义类型成员</h3>
<ul>
<li>类可以自定义某种类型在类中的别名，该<strong>类型名字也是类的成员，存在访问限制</strong>，可以是public或private中的一种</li>
<li>定义类型的成员<strong>必须先定义后使用</strong>，这与普通成员不一样</li>
</ul>
<h3 id="令成员作为内联函数">令成员作为内联函数</h3>
<ul>
<li>定义在类内部的成员函数自动inline</li>
<li>在<strong>类内部声明函数时</strong>，通过inline声明该成员函数为内联</li>
<li>还可以<strong>在类外部定义时</strong>，通过inline声明该成员函数为内流</li>
</ul>
<h3 id="重载成员函数">重载成员函数</h3>
<ul>
<li>与非成员函数类似</li>
</ul>
<h3 id="可变数据成员">可变数据成员</h3>
<ul>
<li>通过在变量声明中假如<code>mutable</code>关键字，使得该成员为可变数据成员</li>
<li><strong>可变数据成员永远不会是const的，即使它是const对象的成员</strong></li>
<li><strong>可以通过const成员函数，改变可变数据成员的值</strong></li>
</ul>
<h3 id="类数据成员的初始值">类数据成员的初始值</h3>
<ul>
<li>当我们提供类内初始值时，<strong>必须用<code>=</code>的初始化形式，或者<code>&#123;&#125;</code>括起的直接初始化形式</strong></li>
</ul>
<h3 id="返回this的成员函数">返回<code>*this</code>的成员函数</h3>
<ul>
<li><p>对于普通成员函数，返回<code>*this</code>就是返回指向本类型对象的引用</p></li>
<li><p>对于<strong>const成员函数</strong>，返回<code>*this</code>意味着返回<strong>指向本类型常量对象的引用</strong>。也就是说从const成员函数返回<code>*this</code>，得到的是常量引用</p></li>
<li><p>基于const的重载，有时候我们希望得到的是普通引用，而非常量引用，因此对于返回<code>*this</code>的成员函数，假如它不修改对象，那么可以定义重载函数，一个是const成员函数，另一个是普通成员函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Screen&amp; <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; reutrn *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="function">Screen&amp; <span class="title">display</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line"><span class="comment">// 如上所示, const对象调用将匹配第一行版本, 非常量对象调用将匹配第二行版本</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="类类型">类类型</h3>
<ul>
<li><strong>每个类定义了唯一的类型</strong>，即使两个类的成员完全一样，这两个类也是不同的类型</li>
</ul>
<h4 id="类的声明">类的声明</h4>
<ul>
<li>类可以仅声明而先不定义它</li>
<li>在类声明后、定义前，它是一种<strong>不完全类型</strong></li>
</ul>
<h4 id="不完全类型可使用的场景">不完全类型可使用的场景</h4>
<ul>
<li>定义指向该类型的指针或引用</li>
<li>声明（但不能定义）以该类型作为参数或返回类型的函数</li>
</ul>
<h4 id="类的成员类型不能是该类自己">类的成员类型不能是该类自己</h4>
<ul>
<li>由于上述不完全类型的原因，<strong>类的成员类型不能是类自己</strong></li>
<li>但类的成员可以是指向该类的指针或引用</li>
</ul>
<h3 id="友元-1">友元</h3>
<ul>
<li>除了把普通函数定义为友元外，还可以<strong>把其他类定义为友元，还可以把其他类的成员函数定义为友元</strong></li>
</ul>
<h4 id="类之间的友元关系">类之间的友元关系</h4>
<ul>
<li><p>指定友元类，可在类定义的开头位置添加以下友元声明，则类C成为友元类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>;</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果一个指定了友元类，则友元类的成员函数可以访问此类的private和public成员</p></li>
<li><p>友元不具有传递性。每个类负责控制自己的友元类或友元函数。</p></li>
</ul>
<h4 id="令成员函数作为友元">令成员函数作为友元</h4>
<ul>
<li><p>将某个类的某个成员函数声明为友元，则该类的该成员函数能否访问此类的private和public成员</p></li>
<li><p>需要明确指出该成员函数属于哪个类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">int</span> <span class="title">C::func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 该友元是C类的成员函数func</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="令成员函数作为友元的定义步骤">令成员函数作为友元的定义步骤</h5>
<ul>
<li>假设<strong>想要令类A的成员函数f作为类B的友元</strong>，必须按照以下方式设计程序
<ul>
<li>定义类A，声明函数f，但不能定义它</li>
<li>定义类B，包含对<code>A::f</code>的友元声明</li>
<li>定义类A的成员函数f，此时它才可以使用类B的成员</li>
</ul></li>
</ul>
<h4 id="友元与重载函数">友元与重载函数</h4>
<ul>
<li>假如类想要让一组重载函数成为自己的友元，则必须<strong>对其中的每个函数分别声明</strong></li>
</ul>
<h4 id="友元声明与作用域">友元声明与作用域</h4>
<ul>
<li>类和非成员函数的声明不一定在它们的友元声明之前</li>
<li>因此，我们在调用友元函数前需要确保它已经被声明</li>
<li>即使友元函数的定义连同友元声明，出现在了类的内部，它也需要在声明后才能使用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 友元函数定义在类的内部*/</span> &#125;</span><br><span class="line">    <span class="built_in">X</span>() &#123; <span class="built_in">f</span>(); &#125;	<span class="comment">// 非法, 友元函数并未声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;	<span class="comment">// 非法, 友元函数并未声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;			<span class="comment">// 这是函数f第一次被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">f</span>(); &#125;	<span class="comment">// 合法, 该友元函数已经被声明</span></span><br></pre></td></tr></table></figure>
<h4 id="关键在于友元声明的作用只改变访问权限它无法取代普通意义上的声明">关键在于，友元声明的作用只改变访问权限，它无法取代普通意义上的声明</h4>
<h2 id="类的作用域">7.4 类的作用域</h2>
<h3 id="作用域和定义在类外部的成员">作用域和定义在类外部的成员</h3>
<ul>
<li><p>一个类就是一个作用域，因此定义在类外部的成员函数，必须通过<code>类名::函数名</code>的形式定义</p></li>
<li><p><strong>一旦遇到类名，定义的剩余部分（函数形参列表、函数体）就位于类作用域之内了</strong>，可以直接使用类的其他成员，无需再次通过作用域运算符取得</p></li>
<li><p>特别地，返回类型出现在类名前，因此<strong>如果返回类型是类成员，需要通过作用域运算符取得授权</strong></p></li>
</ul>
<h3 id="名字查找与类的作用域">名字查找与类的作用域</h3>
<h4 id="类的定义分两步处理">类的定义分两步处理</h4>
<ul>
<li>先编译成员的声明</li>
<li>直到类全部可见后，才编译函数体</li>
<li>因此，成员函数体可以使用类中声明或定义的任何名字，不管声明或定义的次序</li>
</ul>
<h4 id="类型名的特殊之处">类型名的特殊之处</h4>
<ul>
<li>一般地，假如内层作用域使用了外层作用域的名字，该名字仍可以在内层作用域中重新定义</li>
<li>在<strong>类中</strong>，假如<strong>使用了外层作用域中的某个类型名，则不能重新定义该名字</strong></li>
<li>最好在类的开始处，进行类型名的定义</li>
</ul>
<h3 id="成员定义中的普通块作用域的名字查找">成员定义中的普通块作用域的名字查找</h3>
<ul>
<li>成员函数中使用的名字按以下方式解析
<ul>
<li>首先，在<strong>成员函数内</strong>查找该名字的声明，只查找该名字使用前的部分</li>
<li>然后，在<strong>类内</strong>继续查找，所有成员都将考虑</li>
<li>最后，在<strong>成员函数定义之前的作用域内</strong>继续查找</li>
</ul></li>
</ul>
<h2 id="构造函数深入">7.5 构造函数深入</h2>
<h3 id="初始化与赋值的区别">初始化与赋值的区别</h3>
<ul>
<li><p>考虑以下构造函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="built_in">A</span> (<span class="keyword">const</span> string &amp;s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price): <span class="built_in">bookno</span>(s), <span class="built_in">units_soldj</span>(cnt), <span class="built_in">revenue</span>(price*cnt) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>该构造函数使用了构造函数的初始值列表为数据成员初始化，考虑以下构造函数，在构造函数将初始值赋给了各个数据成员，两者看似拥有一样的效果</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="built_in">A</span> (<span class="keyword">const</span> string &amp;s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price) &#123;</span><br><span class="line">      bookno = s;</span><br><span class="line">      units_sold = cnt;</span><br><span class="line">      revenue = price * cnt;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>但实则是有区别的，对于<strong>const成员、引用类型和未提供默认构造函数的类成员</strong>，必须通过构造函数初始值列表对其初始化，而非赋值。如下例所示</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">A</span> (<span class="keyword">int</span> i) &#123;</span><br><span class="line">			cnt = i;		<span class="comment">// 非法, cnt是const int, 无法对其赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">const</span> <span class="keyword">int</span> cnt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="成员初始化的顺序">成员初始化的顺序</h3>
<ul>
<li>构造函数初始值列表只说明用于初始化成员的值，不限定初始化的具体执行顺序</li>
<li><strong>成员的初始化顺序与它们在类中定义的顺序一致</strong></li>
<li>因此，尽量<strong>避免使用某些成员初始化其他成员</strong></li>
</ul>
<h3 id="构造函数的默认实参">构造函数的默认实参</h3>
<ul>
<li>假如一个构造函数<strong>为所有数据成员都提供了默认实参</strong>，那么它实际上定义了<strong>默认构造函数</strong></li>
</ul>
<h3 id="委托构造函数">委托构造函数</h3>
<ul>
<li><p>C++11允许我们定义<strong>委托构造函数</strong>，它使用其所属类的其他构造函数执行自己的初始化过程</p></li>
<li><p>成员初始值列表只有一个唯一入口，就是<strong>类名本身，紧跟圆括号括起的参数列表</strong>，该列表必须与类中另外一个构造函数匹配</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">X</span>(<span class="keyword">int</span> i, <span class="keyword">double</span> j): <span class="built_in">v1</span>(i), <span class="built_in">v2</span>(j) &#123;&#125;</span><br><span class="line"><span class="built_in">X</span>(): <span class="built_in">X</span>(<span class="number">0</span>, <span class="number">0</span>) &#123;&#125;			<span class="comment">// 委托给第一个构造函数</span></span><br><span class="line"><span class="built_in">X</span>(<span class="keyword">int</span> i): <span class="built_in">X</span>(i, <span class="number">0</span>) &#123;&#125;	<span class="comment">// 委托给第一个构造函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>委托构造函数初始化时，<strong>被委托的构造函数的初始值列表和函数体依次被执行</strong></p></li>
</ul>
<h3 id="默认构造函数的作用">默认构造函数的作用</h3>
<ul>
<li>当对象被默认初始化或值初始化时，自动执行默认构造函数</li>
<li>默认初始化发生的场景
<ul>
<li>块作用域内，不使用任何初始值定义一个非静态变量，或数组时</li>
<li>当一个类含有类类型成员，且使用了合成的默认构造函数时</li>
<li>类类型的成员没有在构造函数初始值列表中显式地初始化时</li>
</ul></li>
<li>值初始化发生的场景
<ul>
<li>数组初始化时，提供的初始值数量少于数组大小</li>
<li>不使用初始值定义一个局部静态变量时</li>
<li>通过形如<code>T()</code>表达式显式地请求值初始化时，其中T是类型名</li>
</ul></li>
</ul>
<h3 id="隐式的类类型转换">隐式的类类型转换</h3>
<ul>
<li><p>如果<strong>构造函数只接受一个实参</strong>，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数可称为<strong>转换构造函数</strong></p></li>
<li><p>如Sales_data类有接受一个string的构造函数，则<strong>在需要使用Sales_data的地方可以通过一个string替代</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string book = <span class="string">&quot;123-145-1839&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(book);</span><br></pre></td></tr></table></figure>
<ul>
<li>item是一个Sales_data对象, 其combine函数应该接受一个Sales_data对象,
此处传入string也能成功调用</li>
</ul></li>
</ul>
<h4 id="编译器做的事">编译器做的事</h4>
<ul>
<li>此处编译器用给定的string自动创建了一个<code>Sales_data</code>对象，这个临时的<code>Sales_data</code>对象被传递给<code>combine</code></li>
</ul>
<h4 id="只允许一步类类型转换">只允许一步类类型转换</h4>
<ul>
<li>编译器<strong>只会自动地执行一步类型转换</strong>，假如我们想用一个字符串字面值代替Sales_data对象，那么编译器要先将其转换为string对象，再转为Sales_data对象，这是编译器无法完成的，因此会错误</li>
</ul>
<h4 id="类类型转换并非总是有效的">类类型转换并非总是有效的</h4>
<h4 id="抑制隐式的类类型转换">抑制隐式的类类型转换</h4>
<ul>
<li>这种类类型转换可能并非我们想要的，想要阻止编译器的自动转换，可以<strong>通过在构造函数声明时加上<code>explicit</code>加以阻止</strong></li>
<li><code>explicit</code><strong>只对接受一个实参的构造函数有效</strong></li>
<li>只需在类内部声明构造函数时指定<code>explicit</code>，<strong>在内外定义时无需指定</strong></li>
</ul>
<h4 id="explicit构造函数只能用于直接初始化不能拷贝初始化">explicit构造函数只能用于直接初始化，不能拷贝初始化</h4>
<ul>
<li>当我们执行拷贝初始化时（使用<code>=</code>），也会发生隐式转换</li>
<li>当构造函数被指定为explicit时，将无法使用拷贝初始化，只能直接初始化</li>
</ul>
<h4 id="static_cast可以使用explicit构造函数">static_cast可以使用explicit构造函数</h4>
<ul>
<li><p>尽管explicit阻止了编译器的隐式转换，当可以通过显式转换的形式进行强制转换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string book = <span class="string">&quot;123-145-1839&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(book));</span><br></pre></td></tr></table></figure></li>
<li><p>此外，还可通过该构造函数创建一个临时对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string book = <span class="string">&quot;123-145-1839&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(book));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="标准库中含有explicit构造函数的类">标准库中含有explicit构造函数的类</h3>
<ul>
<li>接受一个单参数的<code>const char*</code>的string构造函数不是explicit的</li>
<li>接受一个单参数的vector构造函数是explicit的</li>
<li>原因是，一般地，我们可以用字符串字面值代替string，这种隐式转换是合理的；但是，我们不能用一个整数代替vector，因此单参数的vector构造函数是explicit的</li>
</ul>
<h3 id="聚合类">聚合类</h3>
<ul>
<li><strong>聚合类</strong>的条件
<ul>
<li><strong>所有成员都是public的</strong></li>
<li><strong>没有定义任何构造函数</strong></li>
<li><strong>没有类内初始值</strong></li>
<li><strong>没有基类，没有virtual函数</strong></li>
</ul></li>
<li>聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式</li>
<li>聚合类的初始化
<ul>
<li>使用<strong>列表初始化</strong>，初始值的顺序必须与声明的顺序一致</li>
<li>如果列表的元素个数少于类的成员变量，则靠后的成员变量被<strong>值初始化</strong></li>
</ul></li>
</ul>
<h3 id="字面值常量类skip">字面值常量类（skip）</h3>
<h2 id="类的静态成员">7.6 类的静态成员</h2>
<h3 id="静态成员">静态成员</h3>
<ul>
<li>当我们需要成员与类本身直接相关，而不是与类的各个对象关联时，需要使用类的静态成员</li>
<li><strong>类的静态成员存在于任何对象之外</strong>，类的对象不包含任何与静态数据成员有关的数据</li>
</ul>
<h3 id="声明静态成员">声明静态成员</h3>
<ul>
<li>成员声明前加上<code>static</code>关键字</li>
<li>静态成员可以是public或private的，可以是常量、引用、指针、类类型等</li>
<li><strong>类的静态数据成员只有一个，被所有该类的对象共享</strong></li>
<li><strong>类的静态成员函数</strong>不与任何对象绑定在一起，<strong>不含有this指针，也不能声明成const的</strong></li>
</ul>
<h3 id="使用静态成员">使用静态成员</h3>
<ul>
<li><p>可使用<strong>作用域运算符</strong>直接访问静态成员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r = Account::<span class="built_in">rate</span>();		<span class="comment">// rate()是Account类的静态成员函数</span></span><br></pre></td></tr></table></figure></li>
<li><p>虽然静态成员不属于任何一个对象，但仍<strong>可以通过类的对象、引用或指针访问静态成员</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Account ac1;</span><br><span class="line">r = ac1.<span class="built_in">rate</span>();		<span class="comment">// 通过Account类的对象访问静态成员</span></span><br></pre></td></tr></table></figure></li>
<li><p><strong>类的成员函数</strong>不需要使用作用域运算符，<strong>可直接访问静态成员</strong></p></li>
</ul>
<h3 id="定义静态成员">定义静态成员</h3>
<ul>
<li>既可以在类的内部、也可以在外部定义静态成员函数，在外部定义时，<strong>不能重复static关键字</strong>，它只出现在类内的成员函数声明</li>
<li><strong>一般地，在类的外部定义并初始化每个静态成员</strong></li>
</ul>
<h3 id="静态成员的类内初始化">静态成员的类内初始化</h3>
<ul>
<li>应该在类外定义并初始化静态成员。但也可以<strong>在类内声明静态成员时，提供类内初始值</strong>，要求初始值必须是<strong>字面值常量类型的<code>constexpr</code></strong></li>
<li>如果提供了类内初始值，那么在类外定义该静态成员时不能再指定一个初始值了</li>
<li><strong>即使提供了类内初始值，最好也在类外定义该初始值</strong></li>
</ul>
<h3 id="静态成员和普通成员的区别">静态成员和普通成员的区别</h3>
<ul>
<li>静态成员可以是不完全类型的，特别地，<strong>静态成员可以是它所属的类类型的</strong>。而普通成员不能时它所属的类类型的</li>
<li>我们<strong>可以使用静态成员作为默认实参</strong>，而不能使用普通成员作为默认实参</li>
</ul>
<h2 id="习题">习题</h2>
<ul>
<li><p>定义类A和类B，其中函数f是B的成员，是A的友元</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">B::f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">   		<span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B::f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    cout &lt;&lt; a.i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>先定义类B，声明f但不定义它</li>
<li>然后定义类A，友元声明</li>
<li>最后在类B外定义成员f，可以使用类A的private和public成员</li>
</ul></li>
<li><p>说明以下代码的<code>Type</code>和<code>initVal</code>分别使用了哪个定义，代码存在错误吗?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string Type;</span><br><span class="line"><span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exercise</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="keyword">typedef</span> <span class="keyword">double</span> Type;</span><br><span class="line">    	<span class="function">Type <span class="title">setVal</span><span class="params">(Type)</span></span>;</span><br><span class="line">    	<span class="function">Type <span class="title">initVal</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    	<span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里返回类型的Type指string, 形参的Type指double</span></span><br><span class="line"><span class="comment">// 应该将返回类型修改为Exercise::Type</span></span><br><span class="line"><span class="function">Type <span class="title">Exercise::setVal</span><span class="params">(Type parm)</span> </span>&#123;</span><br><span class="line">    val = parm + <span class="built_in">initVal</span>();</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>为什么接受单参数的string构造函数不是explicit的，而接受单参数的vector构造函数是explicit的</p></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Young
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/02/13/C++-Primer-Chapter-7/" title="C++ Primer Chapter 7">http://example.com/2022/02/13/C++-Primer-Chapter-7/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/02/13/C++-Primer-%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E9%9B%86/" rel="prev" title="C++ Primer 关键问题集">
                  <i class="fa fa-chevron-left"></i> C++ Primer 关键问题集
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/02/15/C++-Primer-Chapter-8/" rel="next" title="C++ Primer Chapter 8">
                  C++ Primer Chapter 8 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Young</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script>

  




  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
